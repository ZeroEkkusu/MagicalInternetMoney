<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>StealthChad</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="StealthChad (c) Bok Consulting Pty Ltd 2023" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="js/noble-curves.js"></script>
    <script src="globals.js"></script>
    <script src="customNames.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/StealthChad/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/LarvaChad_1532_zoomed_transparentbg.png" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">StealthChad</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Activity'">Activity</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Transfers'">Transfers</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'My Addresses'">My Addresses</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 3; saveSettings();" :active="settings.tabIndex == 3" active-class="active" v-b-popover.hover="'Registry'">Registry</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 4; saveSettings();" :active="settings.tabIndex == 4" active-class="active" v-b-popover.hover="'New Accounts'">Accounts (WIP)</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 5; saveSettings();" :active="settings.tabIndex == 5" active-class="active" v-b-popover.hover="'Config'">Config</b-nav-item>
            <b-avatar v-if="coinbase && coinbase != nameOrAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + nameOrAddress(coinbase, 100)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar>
            <b-button size="sm" variant="outline-primary" class="ml-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? nameOrAddress(coinbase, 16) : 'Connect' }}</b-button>
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Please check your transaction data carefully before signing
          </b-alert>
          <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase || chainId != 11155111">
            <b-card-text>
              Please install the MetaMask extension and connect to the Ethereum Sepolia Testnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
              <br />
              You can switch to the Ethereum Mainnet and click Sync your addresses with ENS names
            </b-card-text>
          </b-card>

          <!-- :MODALACCOUNTNEW -->
          <b-modal id="modal-accountnew" hide-footer size="xl">
            <template #modal-title>
              {{ modalAccount.item.type == "account" ? "Account" : "Stealth Meta-Address" }} Details
            </template>
            <b-form-group label-cols-lg="2" label="Account" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group v-if="modalAccount.item && modalAccount.item.address" label="Address:" label-for="account-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <font size="-1">
                  <b-button size="sm" variant="link" id="account-address" :href="'https://sepolia.etherscan.io/address/' + modalAccount.item.address" v-b-popover.hover.bottom="'Click to view in etherscan.io'" target="_blank">{{ modalAccount.item.address }}</b-button>
                </font>
              </b-form-group>
              <b-form-group label="Name:" label-for="account-name" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="account-name" v-model.trim="modalAccount.name" class="w-100"></b-form-input>
              </b-form-group>
              <b-form-group label="" label-for="account-updatename" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-button size="sm" :disabled="!modalAccount.item || modalAccount.name == modalAccount.item.name" id="account-updatename" @click="updateModalAccountName()" variant="warning">Update</b-button>
              </b-form-group>
              <b-form-group v-if="modalAccount.item" label="ENS Name:" label-for="account-ensname" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Switch to Ethereum Mainnet and Sync to update" class="mx-0 my-1 p-0">
                <b-form-input type="text" readonly size="sm" id="account-ensname" v-model.trim="modalAccount.item.ensName" class="w-100"></b-form-input>
              </b-form-group>
            </b-form-group>
            <!-- <b-form-group label-cols-lg="2" label="Stealth Meta-Addresses" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group v-if="modalAccount.item" label="Stealth Meta-Addresses:" label-for="account-stealthmetaaddresses" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-textarea readonly size="sm" id="account-stealthmetaaddresses" :value="JSON.stringify(modalAccount.item.stealthMetaAddresses, null, 2)" class="w-100" rows="10"></b-form-textarea>
              </b-form-group>
            </b-form-group> -->
          </b-modal>

          <!-- :MODALACCOUNT -->
          <b-modal id="modal-account" hide-footer size="xl">
            <template #modal-title>
              {{ modalAccount.source }} {{ modalAccount.item.address }}
            </template>
            <b-form-group label-cols-lg="2" label="Account" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group v-if="modalAccount.item && modalAccount.item.address" label="Address:" label-for="account-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <font size="-1">
                  <b-button size="sm" variant="link" id="account-address" :href="'https://sepolia.etherscan.io/address/' + modalAccount.item.address" v-b-popover.hover.bottom="'Click to view in etherscan.io'" target="_blank">{{ modalAccount.item.address }}</b-button>
                </font>
              </b-form-group>
              <b-form-group label="Name:" label-for="account-name" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="account-name" v-model.trim="modalAccount.name" class="w-100"></b-form-input>
              </b-form-group>
              <b-form-group label="" label-for="account-updatename" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-button size="sm" :disabled="!modalAccount.item || modalAccount.name == modalAccount.item.name" id="account-updatename" @click="updateModalAccountName()" variant="warning">Update</b-button>
              </b-form-group>
              <b-form-group v-if="modalAccount.item" label="ENS Name:" label-for="account-ensname" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Switch to Ethereum Mainnet and Sync to update" class="mx-0 my-1 p-0">
                <b-form-input type="text" readonly size="sm" id="account-ensname" v-model.trim="modalAccount.item.ensName" class="w-100"></b-form-input>
              </b-form-group>
            </b-form-group>
            <b-form-group label-cols-lg="2" label="Stealth Meta-Addresses" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group v-if="modalAccount.item" label="Stealth Meta-Addresses:" label-for="account-stealthmetaaddresses" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-textarea readonly size="sm" id="account-stealthmetaaddresses" :value="JSON.stringify(modalAccount.item.stealthMetaAddresses, null, 2)" class="w-100" rows="10"></b-form-textarea>
              </b-form-group>
            </b-form-group>
          </b-modal>

          <!-- :MODALACTIVITY -->
          <b-modal id="modal-activity" hide-footer size="xl">
            <template #modal-title>
              <font size="-1">
                Activity ({{ coinbase }})
              </font>
            </template>
            <font size="-1">
              <pre>
{{ modalActivity }}
              </pre>
            </font>
          </b-modal>

          <!-- :MODALADDRESS -->
          <b-modal id="modal-address" hide-footer size="xl">
            <template #modal-title>
              <font size="-1">
                Address ({{ coinbase }})
              </font>
            </template>
            <font size="-1">
              <pre>
{{ modalAddress }}
              </pre>
            </font>
          </b-modal>

          <!-- :MODALNEWSTEALTHMETAADDRESSNEW -->
          <b-modal id="modal-newstealthmetaaddressnew" hide-footer size="lg">
            <template #modal-title>
              Generate New Stealth Meta-Address
            </template>
            <b-form-group label="Attached Account:" label-for="newsma-attachedaccount" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-button size="sm" variant="link" id="newsma-attachedaccount" :href="'https://sepolia.etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Click to view in etherscan.io'" target="_blank">{{ coinbase }}</b-button>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(coinbase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="Name:" label-for="newsma-smaname" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newsma-smaname" v-model.trim="modalNewStealthMetaAddressNew.name" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Phrase:" label-for="newsma-phrase" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0" description="Exact phrase with the attached account is required for recovery of your stealth keys!">
              <b-input-group size="sm" class="w-100">
                <b-form-textarea size="sm" id="newsma-phrase" v-model.trim="modalNewStealthMetaAddressNew.phrase"></b-form-textarea>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalNewStealthMetaAddressNew.phrase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="" label-for="newsma-generate" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Click to sign the phrase above with your web3 attached account" class="mx-0 my-1 p-0">
              <b-button size="sm" id="newsma-generate" @click="generateNewStealthMetaAddressNew()" variant="warning">Generate</b-button>
            </b-form-group>
            <b-form-group v-if="modalNewStealthMetaAddressNew.stealthMetaAddress" label="Stealth Meta-Address:" label-for="newsma-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-textarea size="sm" readonly id="newsma-stealthmetaaddress" :value="modalNewStealthMetaAddressNew.stealthMetaAddress" rows="3"></b-form-textarea>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalNewStealthMetaAddressNew.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalNewStealthMetaAddressNew.stealthMetaAddress" label="" label-for="newsma-addtoaddressbook" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="modalNewStealthMetaAddressNew.status == 'mine' ? 'Update account with stealth keys' : (modalNewStealthMetaAddressNew.status == 'notmine' ? 'Already in accounts, to be claimed' : 'Add new to accounts')" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!modalNewStealthMetaAddressNew.stealthMetaAddress" id="newsma-addtoaddressbook" @click="addStealthMetaAddressToAddressBookNew()" variant="warning">{{ modalNewStealthMetaAddressNew.status == 'mine' ? 'Update' : (modalNewStealthMetaAddressNew.status == 'notmine' ? 'Claim' : 'Add') }}</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWSTEALTHMETAADDRESS -->
          <b-modal id="modal-newstealthmetaaddress" hide-footer size="xl">
            <template #modal-title>
              <font size="-1">
                New Stealth Meta-Address ({{ coinbase }})
              </font>
            </template>
            <b-form-group label-cols-lg="2" label="Account" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group label="Attached Account:" label-for="newsma-attachedaccount" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <font size="-1">
                  <b-button size="sm" variant="link" id="newsma-attachedaccount" :href="'https://sepolia.etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Click to view in etherscan.io'" target="_blank">{{ coinbase }}</b-button>
                </font>
              </b-form-group>
              <b-form-group label="Name:" label-for="newsma-attachedaccountname" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="newsma-attachedaccountname" v-model.trim="modalNewStealthMetaAddress.name" class="w-100"></b-form-input>
              </b-form-group>
              <!-- <b-form-group label="Address:" label-for="approval-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <font size="-1">
                  <b-button size="sm" variant="link" id="approval-address" :href="'https://sepolia.etherscan.io/address/' + modalApproval.item.contract + '#code'" v-b-popover.hover.bottom="'Click to view in etherscan.io'" target="_blank">{{ modalApproval.item.contract }}</b-button>
                </font>
              </b-form-group> -->
            </b-form-group>
            <b-form-group label-cols-lg="2" label="Generate Keys" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group label="Phrase:" label-for="newsma-phrase" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0" description="IMPORTANT: This exact phrase is required to recover your stealth meta-address with your web3 attached account. Save this information securely!">
                <b-form-textarea size="sm" id="newsma-phrase" v-model.trim="modalNewStealthMetaAddress.phrase" class="w-100"></b-form-textarea>
              </b-form-group>
              <b-form-group label="" label-for="newsma-generate" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-button size="sm" id="newsma-generate" @click="generateNewStealthMetaAddress()" variant="warning">Generate</b-button>
              </b-form-group>
            </b-form-group>
            <b-form-group v-if="Object.keys(modalNewStealthMetaAddress.keys).length > 0" label-cols-lg="2" label="Generated Keys" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group label="Spending Private Key:" label-for="newsma-spendingprivatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="newsma-spendingprivatekey" :value="modalNewStealthMetaAddress.keys.spendingPrivateKey" class="w-100"></b-form-input>
              </b-form-group>
              <b-form-group label="Viewing Private Key:" label-for="newsma-viewingprivatekey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="newsma-viewingprivatekey" :value="modalNewStealthMetaAddress.keys.viewingPrivateKey" class="w-100"></b-form-input>
              </b-form-group>
              <b-form-group label="Spending Public Key:" label-for="newsma-spendingpublickey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="newsma-spendingpublickey" :value="modalNewStealthMetaAddress.keys.spendingPublicKey" class="w-100"></b-form-input>
              </b-form-group>
              <b-form-group label="Viewing Public Key:" label-for="newsma-viewingpublickey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="newsma-viewingpublickey" :value="modalNewStealthMetaAddress.keys.viewingPublicKey" class="w-100"></b-form-input>
              </b-form-group>
              <b-form-group label="Stealth Meta-Address:" label-for="newsma-viewingpublickey" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-textarea size="sm" readonly id="newsma-viewingpublickey" :value="modalNewStealthMetaAddress.keys.stealthMetaAddress" class="w-100"></b-form-textarea>
              </b-form-group>
            </b-form-group>
            <b-form-group v-if="Object.keys(modalNewStealthMetaAddress.keys).length > 0" label-cols-lg="2" label="Address Book" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <!-- <b-form-group label="In Address Book:" label-for="newsma-inaddressbook" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-checkbox size="sm" disabled id="newsma-inaddressbook" value="1" :checked="modalNewStealthMetaAddress.keys.inAddressBook ? 1 : 0" class="mt-1"></b-form-checkbox>
              </b-form-group> -->
              <b-form-group label="Name:" label-for="newsma-smaname" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="newsma-smaname" v-model.trim="modalNewStealthMetaAddress.stealthMetaAddressName" class="w-100"></b-form-input>
              </b-form-group>
              <b-form-group label="" label-for="newsma-addtoaddressbook" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="modalNewStealthMetaAddress.keys.inAddressBook ? 'Already in Address Book' : 'Click to add to Address Book'" class="mx-0 my-1 p-0">
                <b-button size="sm" :disabled="modalNewStealthMetaAddress.keys.inAddressBook || !modalNewStealthMetaAddress.stealthMetaAddressName" id="newsma-addtoaddressbook" @click="addStealthMetaAddressToAddressBook()" variant="warning">Add To Address Book</b-button>
              </b-form-group>
            </b-form-group>
            <b-form-group v-if="Object.keys(modalNewStealthMetaAddress.keys).length > 0" label-cols-lg="2" label="Registry" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <!-- <b-form-group label="In Registry:" label-for="newsma-inregistry" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-checkbox size="sm" disabled id="newsma-inregistry" value="1" :checked="modalNewStealthMetaAddress.keys.inRegistry ? 1 : 0" class="mt-1"></b-form-checkbox>
              </b-form-group> -->
              <b-form-group label="" label-for="newsma-addtoregistry" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="modalNewStealthMetaAddress.keys.inRegistry ? 'Already in Registry' : 'Click to add to Registry'" class="mx-0 my-1 p-0">
                <b-button size="sm" :disabled="modalNewStealthMetaAddress.keys.inRegistry" id="newsma-addtoregistry" @click="addStealthMetaAddressToRegistry()" variant="warning">Add To Registry</b-button>
              </b-form-group>
            </b-form-group>
          </b-modal>

          <!-- :MODALAPPROVAL -->
          <b-modal id="modal-approval" hide-footer size="lg">
            <template #modal-title>
              View/Update {{ modalApproval.item.type.toUpperCase() }} {{ modalApproval.item.approvalType }}
            </template>
            <b-form-group v-if="modalApproval.item" label-cols-lg="2" label="Contract" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group v-if="modalApproval.item.contract" label="Address:" label-for="approval-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <font size="-1">
                  <b-button size="sm" variant="link" id="approval-address" :href="'https://sepolia.etherscan.io/address/' + modalApproval.item.contract + '#code'" v-b-popover.hover.bottom="'Click to view in etherscan.io'" target="_blank">{{ modalApproval.item.contract }}</b-button>
                </font>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.symbol" label="Symbol:" label-for="approval-symbol" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="approval-symbol" :value="modalApproval.item.symbol" class="w-25"></b-form-input>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.name" label="Name:" label-for="approval-name" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="approval-name" :value="modalApproval.item.name" class="w-75"></b-form-input>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.type" label="Type:" label-for="approval-type" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="approval-type" :value="accountTypeOptions.filter(e => e.value == modalApproval.item.type)[0].text" class="w-25"></b-form-input>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.decimals" label="Decimals:" label-for="approval-decimals" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="approval-decimals" :value="modalApproval.item.decimals" class="w-25"></b-form-input>
              </b-form-group>
            </b-form-group>
            <b-form-group v-if="modalApproval.item" label-cols-lg="2" label="Approval" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group v-if="modalApproval.item.approvalType" label="Type:" label-for="approval-type" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="approval-type" :value="modalApproval.item.approvalType" class="w-25"></b-form-input>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.owner" label="Owner:" label-for="approval-owner" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <font size="-1">
                  <b-button size="sm" variant="link" id="approval-owner" :href="'https://sepolia.etherscan.io/address/' + modalApproval.item.owner" v-b-popover.hover.bottom="'Click to view in etherscan.io'" target="_blank">{{ modalApproval.item.owner == coinbase ? "(Attached)" : nameOrAddress(modalApproval.item.owner, 42) }}</b-button>
                </font>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.spender" label="Spender:" label-for="approval-spender" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <font size="-1">
                  <b-button size="sm" variant="link" id="approval-spender" :href="'https://sepolia.etherscan.io/address/' + modalApproval.item.spender" v-b-popover.hover.bottom="'Click to view in etherscan.io'" target="_blank">{{ nameOrAddress(modalApproval.item.spender, 42) }}</b-button>
                </font>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.type == 'erc20'" label="Tokens:" label-for="approval-tokens" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="approval-tokens" :value="modalApproval.item.value" class="w-100"></b-form-input>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.type == 'erc721' && modalApproval.item.approvalType == 'Approval'" label="Token Id:" label-for="approval-tokenid" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="approval-tokenid" :value="modalApproval.item.value" class="w-50"></b-form-input>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.approvalType == 'ApprovalForAll'" label="Approved:" label-for="approval-approved" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" readonly id="approval-approved" :value="modalApproval.item.value == 1 ? 'true' : 'false'" class="w-25"></b-form-input>
              </b-form-group>
            </b-form-group>
            <b-form-group v-if="modalApproval.item" label-cols-lg="2" label="Update" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
              <b-form-group v-if="modalApproval.item.type == 'erc20'" label="Tokens:" label-for="approval-update-tokens" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="approval-update-tokens" v-model="modalApproval.tokens" class="w-100" :placeholder="'Number with ' + modalApproval.item.decimals + ' decimal places, e.g., 0'"></b-form-input>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.type == 'erc721' && modalApproval.item.approvalType == 'Approval'" label="Spender:" label-for="approval-update-spender" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="approval-update-spender" v-model="modalApproval.spender" class="w-75" placeholder="Spender, e.g., 0x1234...6789"></b-form-input>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.type == 'erc721' && modalApproval.item.approvalType == 'Approval'" label="Token Id:" label-for="approval-update-tokenid" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-input type="text" size="sm" id="approval-update-tokenid" v-model="modalApproval.tokenId" class="w-50" placeholder="Token Id, e.g., 1234"></b-form-input>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.approvalType == 'ApprovalForAll'" label="Approved:" label-for="approval-update-approved" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-form-select size="sm" id="approval-update-approved" v-model="modalApproval.approved" :options="falseTrueOptions" class="w-25"></b-form-select>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.type == 'erc20'" label="" label-for="approval-update-submit1" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-button size="sm" :disabled="!modalApproval.tokens || modalApproval.item.owner != coinbase" id="approval-update-submit1" @click="updateApproval()" variant="warning">Update</b-button>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.type == 'erc721' && modalApproval.item.approvalType == 'Approval'" label="" label-for="approval-update-submit2" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-button size="sm" :disabled="!modalApproval.spender || !modalApproval.tokenId || modalApproval.item.owner != coinbase" id="approval-update-submit2" @click="updateApproval()" variant="warning">Update</b-button>
              </b-form-group>
              <b-form-group v-if="modalApproval.item.approvalType == 'ApprovalForAll'" label="" label-for="approval-update-submit3" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                <b-button size="sm" :disabled="modalApproval.item.owner != coinbase" id="approval-update-submit3" @click="updateApproval()" variant="warning">Update</b-button>
              </b-form-group>
            </b-form-group>
          </b-modal>

          <!-- :MODALREGISTRY -->
          <b-modal id="modal-registry" hide-footer size="xl">
            <template #modal-title>
              <font size="-1">
                Registry ({{ coinbase }})
              </font>
            </template>
            <font size="-1">
              <pre>
{{ modalRegistry }}
              </pre>
            </font>
          </b-modal>

          <!-- :MODALCONTRACT -->
          <b-modal id="modal-contract" hide-footer size="xl">
            <template #modal-title>
              {{ contractTypeOptions.filter(e => e.value == modalContract.item.type)[0] && contractTypeOptions.filter(e => e.value == modalContract.item.type)[0].text || ("Unknown: " + modalContract.item.type) }} {{ modalContract.item.contract }}
            </template>
            <b-card no-body no-header bg-variant="light" class="m-1 p-1">
              <b-form-group label-cols-lg="2" label="Contract" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                <b-form-group v-if="modalContract.item && modalContract.item.chainId" label="Chain:" label-for="contract-chain" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-button size="sm" disabled variant="none" id="contract-chain">{{ chains.filter(e => e.value == modalContract.item.chainId)[0] && chains.filter(e => e.value == modalContract.item.chainId)[0].text || ("Id: " + modalContract.item.chainId) }}</b-button>
                </b-form-group>
                <b-form-group v-if="modalContract.item && modalContract.item.contract" label="Address:" label-for="contract-address" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-button size="sm" variant="link" id="contract-address" :href="'https://sepolia.etherscan.io/address/' + modalContract.item.contract" v-b-popover.hover.bottom="'Click to view in etherscan.io'" target="_blank">{{ modalContract.item.contract }}</b-button>
                </b-form-group>
                <b-form-group v-if="modalContract.item && modalContract.item.type" label="Type:" label-for="contract-type" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-button size="sm" disabled variant="none" id="contract-type">{{ contractTypeOptions.filter(e => e.value == modalContract.item.type)[0] && contractTypeOptions.filter(e => e.value == modalContract.item.type)[0].text || ("Unknown: " + modalContract.item.type) }}</b-button>
                </b-form-group>
                <b-form-group v-if="modalContract.item && modalContract.item.timestamp" label="First Event:" label-for="contract-timestamp" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-button size="sm" variant="link" id="contract-timestamp" :href="'https://sepolia.etherscan.io/block/' + modalContract.item.blockNumber" v-b-popover.hover.bottom="'Block #' + commify0(modalContract.item.blockNumber)" target="_blank">{{ formatTimestamp(modalContract.item.timestamp) }}</b-button>
                </b-form-group>
                <b-form-group label="Name:" label-for="modalcontract-name" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-input-group size="sm" class="w-100">
                    <b-form-input type="text" size="sm" id="modalcontract-name" v-model.trim="modalContract.name"></b-form-input>
                    <b-input-group-append>
                      <b-button :disabled="modalContract.name == (modalContract.item && modalContract.item.name)" @click="saveModalContractName();" variant="link" class="m-0 ml-2 p-0"><b-icon-pencil-square shift-v="+1" font-scale="1.1"></b-icon-pencil-square></b-button>
                    </b-input-group-append>
                  </b-input-group>
                </b-form-group>
              </b-form-group>
            </b-card>
            <b-card no-body no-header bg-variant="light" class="m-1 p-1">
              <b-form-group label-cols-lg="2" label="Settings" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                <b-form-group label="Read:" label-for="contract-read" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Read event logs involving this contract" class="mx-0 my-1 p-0">
                  <b-form-checkbox size="sm" id="contract-read" value="1" :checked="modalContract.read ? 1 : 0" @change="toggleContractRead()" class="mt-1"></b-form-checkbox>
                </b-form-group>
                <b-form-group label="Write:" label-for="contract-write" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Send transactions to contract, where supported" class="mx-0 my-1 p-0">
                  <b-form-checkbox size="sm" id="contract-write" value="1" :checked="modalContract.write ? 1 : 0" @change="toggleContractWrite()" class="mt-1"></b-form-checkbox>
                </b-form-group>
              </b-form-group>
            </b-card>
          </b-modal>

          <b-card class="m-0 p-0 border-0" body-class="m-1 p-0">
            <!-- :TOOLBAR -->
            <b-card-text v-if="coinbase" class="m-0 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <!-- <div v-if="false && (settings.tabIndex == 0 || settings.tabIndex == 1)" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" :disabled="sync.section != null" v-model.trim="settings.searchAttachedAccount" @input="saveSettings" v-b-popover.hover.bottom="'Search for approval events emitted by your attached web3 account'">
                    Attached
                  </b-form-checkbox>
                </div> -->
                <!-- <div v-if="false && !settings.searchAttachedAccount" class="mt-0 pr-1" style="width: 25.0rem;">
                  <b-form-textarea :disabled="sync.section != null" size="sm" v-model.trim="settings.searchAccounts" @change="saveSettings" debounce="600" rows="3" max-rows="10" v-b-popover.hover.top="'Search for approval events emitted this list of owner addresses'" :placeholder="'0x12...34\n0x23...45 0x34...56'"></b-form-textarea>
                </div> -->
                <!-- <div v-if="false && settings.tabIndex == 0" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" v-model.trim="settings.approvalsTable.includeInactive" @input="saveSettings" v-b-popover.hover.bottom="'Include inactive approvals'">
                    Inactive
                  </b-form-checkbox>
                </div> -->
                <!-- <div v-if="false && settings.tabIndex == 1" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" v-model.trim="settings.eventsTable.includeFluff" @input="saveSettings" v-b-popover.hover.bottom="'Include less important events like ERC-721 Approval to Null:0x0000...0000'">
                    Fluff
                  </b-form-checkbox>
                </div> -->
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex != 5 && !sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="saveSettings(); syncIt(false);" variant="primary" v-b-popover.hover.bottom="'Sync stealth address announcement events'">Sync</b-button>
                </div>
                <div v-if="settings.tabIndex != 5 && !sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="saveSettings(); syncIt(true);" variant="outline-primary" v-b-popover.hover.bottom="'This will do dev things'">Dev</b-button>
                </div>
                <div v-if="sync.section" class="mt-1 p-0" style="width: 300px;">
                  <b-progress height="1.5rem" :max="sync.total" show-progress :animated="!sync.section" :variant="sync.section ? 'success' : 'secondary'" v-b-popover.hover.bottom="'Click the button on the right to stop this process'">
                    <b-progress-bar :value="sync.completed">
                      {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                    </b-progress-bar>
                  </b-progress>
                </div>
                <!-- <div class="ml-0 mt-1">
                  <b-link v-if="sync.section" size="sm" @click="halt" variant="link" v-b-popover.hover.bottom="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-link>
                </div> -->
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-button size="sm" @click="newStealthMetaAddress" variant="link" v-b-popover.hover.bottom="'Add new Stealth Meta-Address'"><b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus></b-button>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-0 pl-1">
                  <b-button size="sm" @click="newStealthMetaAddressNew" variant="link" v-b-popover.hover.bottom="'Add new Stealth Meta-Address'"><b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div class="mt-0 pl-1">
                  <b-button size="sm" :pressed.sync="settings.showInfo" @click="saveSettings" variant="link" v-b-popover.hover.bottom="'Show info'"><span v-if="settings.showInfo"><b-icon-info-circle-fill shift-v="+1" font-scale="1.0"></b-icon-info-circle-fill></span><span v-else><b-icon-info-circle shift-v="+1" font-scale="1.0"></b-icon-info-circle></span></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex == 0" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.activityTable.sortOption" @change="saveSettings" :options="activitySortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.addressesTable.sortOption" @change="saveSettings" :options="addressesSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.registryActivityTable.sortOption" @change="saveSettings" :options="registryActivitySortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.accountsTable.sortOption" @change="saveSettings" :options="accountsSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 0" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# events'">{{ commify0(filteredActivity.length) + '/' + commify0(announcements.length) }}</font>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# addresses'">{{ /*commify0(filteredApprovals.length) + '/' +*/ commify0(totalAddresses) }}</font>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# registry events'">{{ commify0(filteredRegistryActivity.length) + '/' + commify0(registryEntries.length) }}</font>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-0 pl-1">
                  <!-- TODO -->
                  <font size="-2" v-b-popover.hover.bottom="'# registry events'">{{ commify0(filteredAccounts.length) + '/' + commify0(totalAccounts) }}</font>
                </div>
                <div v-if="settings.tabIndex == 0" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.activityTable.currentPage" @input="saveSettings" :total-rows="filteredActivity.length" :per-page="settings.activityTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.addressesTable.currentPage" @input="saveSettings" :total-rows="totalAddresses" :per-page="settings.addressesTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.registryActivityTable.currentPage" @input="saveSettings" :total-rows="filteredRegistryActivity.length" :per-page="settings.registryActivityTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-0 pl-1">
                  <!-- TODO -->
                  <b-pagination size="sm" v-model="settings.accountsTable.currentPage" @input="saveSettings" :total-rows="filteredAccounts.length" :per-page="settings.accountsTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 0" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.activityTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.addressesTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.registryActivityTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.accountsTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
              </div>
            </b-card-text>

            <b-card-text class="m-0 p-0">
              <!-- :INFO -->
              <b-card v-if="settings.showInfo || coinbase == null" no-body class="my-1 p-1">
                <b-card-body class="mt-1 p-1">
                  <h4>Welcome</h4>
                  Stealth Chad - Exploring <b-link href="https://eips.ethereum.org/EIPS/eip-5564" target="_blank">ERC-5564: Stealth Addresses</b-link>

                  <!-- A lightweigh web3 dapp tool to manage your approvals for ERC-20, ERC-721 and ERC-1155 token contracts on Ethereum-Virtual-Machine compatible chains. -->

                  <!-- <h5 class="mt-4">How This Works</h5>
                  <ul>
                    <li>This tool scans for <b-link href="https://eips.ethereum.org/EIPS/eip-20#events" target="_blank">ERC-20</b-link>, <b-link href="https://eips.ethereum.org/EIPS/eip-721#specification" target="_blank">ERC-721</b-link> and <b-link href="https://eips.ethereum.org/EIPS/eip-1155#specification" target="_blank">ERC-1155</b-link> <b>Approval</b> and <b>ApprovalForAll</b> log events from the owner's account. This is done using the <b-link href="https://docs.ethers.org/v5/api/providers/provider/#Provider-getLogs" target="_blank">getLogs(filter)</b-link> web3 call</li>
                    <li>These event logs are then processed to determine the approval states for the various ERC-20, ERC-721 and ERC-1155 contracts</li>
                    <li>The latest ERC-20 approval amounts are retrieved using the ERC-20 <b>allowance(...)</b> function</li>
                  </ul> -->

                  <!-- <h5 class="mt-3">Requirements</h5>
                  <ul>
                    <li>This dapp runs in web3 enabled desktop browsers connected to the Ethereum mainnet, and should work with other Ethereum-Virtual-Machine compatible chains</li>
                  </ul> -->

                  <h5 class="mt-3">Contracts on Sepolia</h5>
                  <ul>
                    <li><b-link href="https://sepolia.etherscan.io/address/0x4f58404f363f8a3282648e80440e075e5c1e28a1#code" target="_blank">ERC5564Announcer</b-link></li>
                    <li><b-link href="https://sepolia.etherscan.io/address/0xC5F111011acAd96860a3cd3d7C50Dd8f56a5684e#code" target="_blank">ERC5564Registry v0.8.0</b-link></li>
                    <li><b-link href="https://sepolia.etherscan.io/address/0x3834bcA9093e375893D65975ad765179A149D017#code" target="_blank">StealthChad v0.8.0</b-link></li>
                  </ul>

                  <h5 class="mt-3">References</h5>
                  <ul>
                    <li><b-link href="https://eips.ethereum.org/EIPS/eip-5564" target="_blank">ERC-5564: Stealth Addresses</b-link></li>
                    <li><b-link href="https://eips.ethereum.org/EIPS/eip-6538" target="_blank">ERC-6538: Stealth Meta-Address Registry</b-link></li>
                  </ul>

                  <h5 class="mt-3">This Dapp</h5>
                  <ul>
                    <li>Dapp: <b-link href="https://bokkypoobah.github.io/StealthChad/" target="_blank">https://bokkypoobah.github.io/StealthChad/</b-link></li>
                    <li>GitHub: <b-link href="https://github.com/bokkypoobah/StealthChad" target="_blank">https://github.com/bokkypoobah/StealthChad</b-link></li>
                    <li>Main Dapp Source Code: <b-link href="https://github.com/bokkypoobah/StealthChad/blob/main/docs/index.html" target="_blank">https://github.com/bokkypoobah/StealthChad/blob/main/docs/index.html</b-link></li>
                  </ul>

                  <!-- <h5 class="mt-3">Running Locally</h5>
                  <ul>
                    <li>In a folder on your computer, <b>git clone <b-link href="https://github.com/bokkypoobah/StealthChad" target="_blank">https://github.com/bokkypoobah/StealthChad</b-link></b></li>
                    <li>Run a tool like <b-link href="https://www.npmjs.com/package/anywhere" target="_blank">anywhere</b-link> in the <b>./docs</b> subdirectory of the folder created above</li>
                  </ul> -->

                  <!-- <h5 class="mt-3">Design</h5>
                  <ul>
                    <li>This dapp is designed to have minimal external dependencies - all code is statically served from GitHub</li>
                    <li>No backend servers are necessary, only a web3 connection</li>
                  </ul> -->

                  <!-- <h5 class="mt-3">Warning</h5>
                  <ul>
                    <li>This is experimental unaudited software. Please check your transaction data carefully when updating your approvals!</li>
                  </ul> -->

                  <h5 class="mt-3">Troubleshooting</h5>
                  <ul>
                    <li>If this dapp is not receiving the latest Mainnet data, reset your MetaMask web3 connection using <b>Settings</b> -> <b>Advanced</b> -> <b>Clear activity and nonce data</b></li>
                    <li>Reset this dapp data by removing LocalStorage entries with the keys beginning with <b>stealthChad</b></li>
                  </ul>
                </b-card-body>
              </b-card>


              <!-- :ACTIVITY -->
              <b-table v-if="settings.tabIndex == 0 && !settings.showInfo" ref="activityTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='activityRowSelected' :fields="activityFields" :items="pagedFilteredSortedActivity" show-empty empty-html="Click Sync above to retrieve stealth address announcement events" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.activityTable.currentPage - 1) * settings.activityTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="'https://sepolia.etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                </template>
                <template #cell(sender)="data">
                  <b-link v-if="data.item.tx && data.item.tx.from" @click="viewAccount(data.item.tx.from, 'sender')">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.tx.from)" class="px-0">{{ nameOrAddress(data.item.tx.from, 28) }}</b-badge>
                  </b-link>
                </template>
                <template #cell(receiver)="data">
                  <b-link @click="viewAccount(data.item.stealthAddress, 'receiver')">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.stealthAddress)" class="px-0">{{ nameOrAddress(data.item.stealthAddress, 28) }}</b-badge>
                  </b-link>
                </template>
                <template #cell(details)="data">
                  <font size="-2">
                    schemeId: {{ data.item.schemeId }}, ephemeralPublicKey: {{ data.item.ephemeralPublicKey }}, metadata: {{ data.item.metadata }}
                  </font>
                  <!-- <br />
                  <font size="-1">
                    <pre>
{{ data.item }}
                    </pre>
                  </font> -->
                  <!-- <b-badge pill variant="transparent" class="px-0">{{ accountTypeOptions.filter(e => e.value == data.item.type)[0].text }}</b-badge> -->
                </template>
              </b-table>

              <!-- :TRANSFERS -->
              <b-card v-if="settings.tabIndex == 1 && !settings.showInfo && coinbase != null" no-body class="my-1 p-1">
                <b-card-body class="mt-1 p-1">
                  <h5>Transfer ETH From EOA To Stealth Meta-Address</h5>
                  <b-form-group label-cols-lg="2" label="Transfer Details" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                    <b-form-group label="Recipient Stealth Meta Address:" label-for="recipient-stealth-meta-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-textarea type="text" id="recipient-stealth-meta-address" v-model.trim="settings.transfer.recipientStealthMetaAddress" @input="saveSettings"></b-form-textarea>
                        <b-input-group-append>
                          <b-button :disabled="!settings.transfer.recipientStealthMetaAddress" @click="copyToClipboard(settings.transfer.recipientStealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                    <b-form-group label="Amount:" label-for="transfer-amount" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0" description="Amount in ETH">
                      <b-form-input type="text" size="sm" id="transfer-amount" v-model.trim="settings.transfer.amount" @input="saveSettings" class="w-50"></b-form-input>
                    </b-form-group>
                    <b-form-group label="" label-for="transfer-transfer" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-button size="sm" id="transfer-transfer" @click="transferEthToStealthMetaAddress()" variant="warning">Transfer</b-button>
                    </b-form-group>
                  </b-form-group>
                </b-card-body>
              </b-card>

              <!-- :ADDRESSES -->
              <b-table v-if="settings.tabIndex == 2 && !settings.showInfo" ref="addressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='addressesRowSelected' :fields="addressesFields" :items="pagedFilteredSortedAddresses" show-empty empty-html="Click Sync above to retrieve stealth address registry events before adding new entries" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.addressesTable.currentPage - 1) * settings.addressesTable.pageSize) + 1 }}
                  </font>
                </template>
                <!-- <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="'https://sepolia.etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                </template> -->
                <template #cell(address)="data">
                  <b-link @click="viewAccount(data.item.address, 'address')">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.address)" class="px-0">{{ nameOrAddress(data.item.address, 28) }}</b-badge>
                  </b-link>
                </template>
                <template #cell(contract)="data">
                  <b-link :href="'https://sepolia.etherscan.io/address/' + data.item.contract" target="_blank">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.contract)" class="px-0">{{ nameOrAddress(data.item.contract, 28) }}</b-badge>
                  </b-link>
                </template>
                <template #cell(details)="data">
                  <font size="-1">
                    <pre>
      {{ data.item }}
                    </pre>
                  </font>
                </template>
              </b-table>

              <!-- :ADDRESSES OLD -->
              <b-card v-if="settings.tabIndex == 200 && !settings.showInfo && coinbase != null" no-body class="my-1 p-1">
                <b-card-body class="mt-1 p-1">
                  <h5>Stealth Meta-Address</h5>
                  <b-form-group label-cols-lg="2" label="Generate Keys" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                    <b-form-group label="Message:" label-for="generate-keys-message" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0" description="IMPORTANT: This exact message is required to recover your stealth meta-address with your web3 attached account. Save this information securely!">
                      <b-form-input type="text" size="sm" id="generate-keys-message" v-model.trim="settings.stealthMetaAddress.message" @input="saveSettings" class="w-50"></b-form-input>
                    </b-form-group>
                    <b-form-group label="" label-for="generate-keys-submit" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-button size="sm" id="generate-keys-submit" @click="generateKeys()" variant="warning">Generate</b-button>
                    </b-form-group>
                  </b-form-group>
                  <b-form-group label-cols-lg="2" label="Private Keys" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                    <b-form-group label="" label-for="display-private-keys" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-form-checkbox size="sm" v-model.trim="stealthMetaAddress.display">Display Private Keys</b-form-checkbox>
                    </b-form-group>
                    <b-form-group label="Spending Private Key:" label-for="spending-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-input type="text" readonly id="spending-privatekey" :value="stealthMetaAddress.display ? stealthMetaAddress.spendingPrivateKey : (stealthMetaAddress.spendingPrivateKey ? '*'.repeat(66) : '')" class="w-75"></b-form-input>
                        <b-input-group-append>
                          <b-button :disabled="!stealthMetaAddress.spendingPrivateKey" @click="copyToClipboard(stealthMetaAddress.spendingPrivateKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                    <b-form-group label="Viewing Private Key:" label-for="viewing-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-input type="text" readonly id="viewing-privatekey" :value="stealthMetaAddress.display ? stealthMetaAddress.viewingPrivateKey : (stealthMetaAddress.viewingPrivateKey ? '*'.repeat(66) : '')" class="w-75"></b-form-input>
                        <b-input-group-append>
                          <b-button :disabled="!stealthMetaAddress.viewingPrivateKey" @click="copyToClipboard(stealthMetaAddress.viewingPrivateKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                  </b-form-group>
                  <b-form-group label-cols-lg="2" label="Public Keys" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                    <b-form-group label="Spending Public Key:" label-for="spending-publickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-input type="text" readonly id="spending-publickey" :value="settings.stealthMetaAddress.spendingPublicKey" class="w-75"></b-form-input>
                        <b-input-group-append>
                          <b-button :disabled="!settings.stealthMetaAddress.spendingPublicKey" @click="copyToClipboard(settings.stealthMetaAddress.spendingPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                    <b-form-group label="Viewing Public Key:" label-for="viewing-publickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-input type="text" readonly id="viewing-publickey" :value="settings.stealthMetaAddress.viewingPublicKey" class="w-75"></b-form-input>
                        <b-input-group-append>
                          <b-button :disabled="!settings.stealthMetaAddress.viewingPublicKey" @click="copyToClipboard(settings.stealthMetaAddress.viewingPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                    <b-form-group label="Stealth Meta Address:" label-for="stealth-meta-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-textarea type="text" readonly id="stealth-meta-address" :value="settings.stealthMetaAddress.stealthMetaAddress"></b-form-textarea>
                        <b-input-group-append>
                          <b-button :disabled="!settings.stealthMetaAddress.stealthMetaAddress" @click="copyToClipboard(settings.stealthMetaAddress.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                  </b-form-group>
                  <b-form-group label-cols-lg="2" label="Register Stealth Meta Address" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                    <b-form-group label="" label-for="register-keys-submit" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-button size="sm" id="register-keys-submit" @click="registerKey()" variant="warning">Register</b-button>
                    </b-form-group>
                  </b-form-group>
                </b-card-body>
              </b-card>

              <!-- :REGISTRY -->
              <b-table v-if="settings.tabIndex == 3 && !settings.showInfo" ref="registryTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='registryRowSelected' :fields="registryActivityFields" :items="pagedFilteredSortedRegistryActivity" show-empty empty-html="Click Sync above to retrieve stealth address registry events" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.registryActivityTable.currentPage - 1) * settings.registryActivityTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="'https://sepolia.etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                </template>
                <template #cell(registrant)="data">
                  <b-link @click="viewAccount(data.item.registrant, 'registrant')">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.registrant)" class="px-0">{{ nameOrAddress(data.item.registrant, 28) }}</b-badge>
                  </b-link>
                </template>
                <template #cell(schemeId)="data">
                  <b-badge pill variant="transparent" class="px-0">{{ data.item.schemeId }}</b-badge>
                </template>
                <template #cell(stealthMetaAddress)="data">
                  <font size="-1">
                    <!-- <b-badge pill variant="transparent" v-b-popover.hover="data.item.stealthMetaAddress" class="px-0"> -->
                      {{ data.item.stealthMetaAddress }}
                    <!-- </b-badge> -->
                  </font>
                  <!-- <font size="-2">
                    <pre>
    {{ data.item }}
                    </pre>
                  </font> -->
                </template>
                <!-- <template #cell(contract)="data">
                  <b-link :href="'https://sepolia.etherscan.io/address/' + data.item.contract" target="_blank">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.contract)" class="px-0">{{ nameOrAddress(data.item.contract, 28) }}</b-badge>
                  </b-link>
                </template> -->
                <!-- <template #cell(details)="data">
                  <font size="-1">
                    <pre>
      {{ data.item }}
                    </pre>
                  </font>
                </template> -->
              </b-table>

              <!-- :ACCOUNTS -->
              <b-table v-if="settings.tabIndex == 4 && !settings.showInfo" ref="accountsTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='accountsRowSelected' :fields="accountsFields" :items="pagedFilteredSortedAccounts" show-empty empty-html="Click Sync above to retrieve stealth address registry events before adding new entries" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.accountsTable.currentPage - 1) * settings.accountsTable.pageSize) + 1 }}
                  </font>
                </template>
                <!-- <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="'https://sepolia.etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                </template> -->
                <template #cell(address)="data">
                  <!-- <b-link @click="viewAccount(data.item.address, 'address')"> -->
                  <b-link :href="'https://sepolia.etherscan.io/address/' + data.item.address" target="_blank">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.address)" class="px-0">{{ nameOrAddress(data.item.address, 28) }}</b-badge>
                  </b-link>
                </template>
                <template #cell(contract)="data">
                  <b-link :href="'https://sepolia.etherscan.io/address/' + data.item.contract" target="_blank">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.contract)" class="px-0">{{ nameOrAddress(data.item.contract, 28) }}</b-badge>
                  </b-link>
                </template>
                <template #cell(details)="data">
                  <font size="-1">
                    <pre>
      {{ data.item }}
                    </pre>
                  </font>
                </template>
              </b-table>

              <!-- :CONFIG -->
              <b-card v-if="settings.tabIndex == 5 && !settings.showInfo && coinbase != null" no-body class="my-1 p-1">
                <b-card-body class="mt-1 p-1">
                  <h5>Configure Contracts</h5>
                  <b-card no-body no-header bg-variant="light" class="m-1 p-1">
                    <!-- <b-form-group label-cols-lg="2" label="Search" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                      <b-form-group label="" label-for="config-search" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-button size="sm" id="config-search" @click="searchForContracts()" variant="warning">Search</b-button>
                      </b-form-group>
                    </b-form-group> -->
                    <div class="d-flex flex-wrap m-0 p-0">
                      <div class="mt-0 flex-grow-1">
                      </div>
                      <div v-if="!sync.section" class="mt-0 pr-1">
                        <b-button size="sm" @click="saveSettings(); searchForContracts();" variant="primary" v-b-popover.hover.bottom="'Scan connected network for ERC-5564 and ERC-6538(with bytes32) events'">Scan</b-button>
                      </div>
                      <div class="mt-0 flex-grow-1">
                      </div>
                      <div class="mt-0 pl-1">
                        <b-form-select size="sm" v-model="settings.contractsTable.sortOption" @change="saveSettings" :options="contractsSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                      </div>
                      <div class="mt-0 pl-1">
                        <font size="-2" v-b-popover.hover.bottom="'# contracts'">{{ commify0(totalContracts) }}</font>
                      </div>
                      <div class="mt-0 pl-1">
                        <b-pagination size="sm" v-model="settings.contractsTable.currentPage" @input="saveSettings" :total-rows="totalContracts" :per-page="settings.contractsTable.pageSize" style="height: 0;"></b-pagination>
                      </div>
                      <div class="mt-0 pl-1">
                        <b-form-select size="sm" v-model="settings.contractsTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                      </div>
                    </div>

                    <b-table ref="contractsTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='contractRowSelected' :fields="contractsFields" :items="pagedFilteredSortedContracts" show-empty empty-html="Click Sync above to retrieve stealth address announcement events" head-variant="light" class="mx-0 my-1">
                      <template #cell(number)="data">
                        <font size="-1">
                          {{ parseInt(data.index) + ((settings.contractsTable.currentPage - 1) * settings.contractsTable.pageSize) + 1 }}
                        </font>
                      </template>
                      <template #cell(chainId)="data">
                        <font size="-1">
                          {{ chains.filter(e => e.value == data.item.chainId)[0] && chains.filter(e => e.value == data.item.chainId)[0].text || ("Id: " + data.item.chainId) }}
                        </font>
                      </template>
                      <template #cell(contract)="data">
                        <!-- <b-link @click="viewContract(data.item.contract, 'contract')"> -->
                        <b-link :href="'https://sepolia.etherscan.io/address/' + data.item.contract + '#code'" target="_blank">
                          <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.contract)" class="px-0">{{ nameOrAddress(data.item.contract, 28) }}</b-badge>
                        </b-link>
                      </template>
                      <template #cell(type)="data">
                        <font size="-1">
                          {{ contractTypeOptions.filter(e => e.value == data.item.type)[0] && contractTypeOptions.filter(e => e.value == data.item.type)[0].text || ("Unknown: " + data.item.type) }}
                        </font>
                      </template>
                      <template #cell(name)="data">
                        <font size="-1">
                          {{ data.item.name }}
                        </font>
                      </template>
                      <template #cell(firstEvent)="data">
                        <font size="-1">
                          <b-link :href="'https://sepolia.etherscan.io/block/' + data.item.blockNumber" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber)" target="_blank">
                            <span v-if="data.item.timestamp">
                              {{ formatTimestamp(data.item.timestamp) }}
                            </span>
                            <span v-else>
                              {{ '#' + commify0(data.item.blockNumber) }}
                            </span>
                          </b-link>
                        </font>
                      </template>
                      <template #cell(read)="data">
                        <font size="-1">
                          <b-form-checkbox size="sm" disabled value="1" :checked="data.item.read ? 1 : 0" class="mt-1"></b-form-checkbox>
                        </font>
                      </template>
                      <template #cell(write)="data">
                        <font size="-1">
                          <b-form-checkbox size="sm" disabled value="1" :checked="data.item.write ? 1 : 0" @input="toggleContractWrite(data.item)" class="mt-1"></b-form-checkbox>
                        </font>
                      </template>
                      <!-- <b-form-checkbox size="sm" disabled id="newsma-inaddressbook" value="1" :checked="modalNewStealthMetaAddress.keys.inAddressBook ? 1 : 0" class="mt-1"></b-form-checkbox> -->
                    </b-table>
                  </b-card>

                  <!-- <b-form-group label-cols-lg="2" label="Generate Keys" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                    <b-form-group label="Message:" label-for="generate-keys-message" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0" description="IMPORTANT: This exact message is required to recover your stealth meta-address with your web3 attached account. Save this information securely!">
                      <b-form-input type="text" size="sm" id="generate-keys-message" v-model.trim="settings.stealthMetaAddress.message" @input="saveSettings" class="w-50"></b-form-input>
                    </b-form-group>
                    <b-form-group label="" label-for="generate-keys-submit" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-button size="sm" id="generate-keys-submit" @click="generateKeys()" variant="warning">Generate</b-button>
                    </b-form-group>
                  </b-form-group> -->
                  <!-- <b-form-group label-cols-lg="2" label="Private Keys" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                    <b-form-group label="" label-for="display-private-keys" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-form-checkbox size="sm" v-model.trim="stealthMetaAddress.display">Display Private Keys</b-form-checkbox>
                    </b-form-group>
                    <b-form-group label="Spending Private Key:" label-for="spending-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-input type="text" readonly id="spending-privatekey" :value="stealthMetaAddress.display ? stealthMetaAddress.spendingPrivateKey : (stealthMetaAddress.spendingPrivateKey ? '*'.repeat(66) : '')" class="w-75"></b-form-input>
                        <b-input-group-append>
                          <b-button :disabled="!stealthMetaAddress.spendingPrivateKey" @click="copyToClipboard(stealthMetaAddress.spendingPrivateKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                    <b-form-group label="Viewing Private Key:" label-for="viewing-privatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-input type="text" readonly id="viewing-privatekey" :value="stealthMetaAddress.display ? stealthMetaAddress.viewingPrivateKey : (stealthMetaAddress.viewingPrivateKey ? '*'.repeat(66) : '')" class="w-75"></b-form-input>
                        <b-input-group-append>
                          <b-button :disabled="!stealthMetaAddress.viewingPrivateKey" @click="copyToClipboard(stealthMetaAddress.viewingPrivateKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                  </b-form-group> -->
                  <!-- <b-form-group label-cols-lg="2" label="Public Keys" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                    <b-form-group label="Spending Public Key:" label-for="spending-publickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-input type="text" readonly id="spending-publickey" :value="settings.stealthMetaAddress.spendingPublicKey" class="w-75"></b-form-input>
                        <b-input-group-append>
                          <b-button :disabled="!settings.stealthMetaAddress.spendingPublicKey" @click="copyToClipboard(settings.stealthMetaAddress.spendingPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                    <b-form-group label="Viewing Public Key:" label-for="viewing-publickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-input type="text" readonly id="viewing-publickey" :value="settings.stealthMetaAddress.viewingPublicKey" class="w-75"></b-form-input>
                        <b-input-group-append>
                          <b-button :disabled="!settings.stealthMetaAddress.viewingPublicKey" @click="copyToClipboard(settings.stealthMetaAddress.viewingPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                    <b-form-group label="Stealth Meta Address:" label-for="stealth-meta-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-input-group size="sm" class="w-75">
                        <b-form-textarea type="text" readonly id="stealth-meta-address" :value="settings.stealthMetaAddress.stealthMetaAddress"></b-form-textarea>
                        <b-input-group-append>
                          <b-button :disabled="!settings.stealthMetaAddress.stealthMetaAddress" @click="copyToClipboard(settings.stealthMetaAddress.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                        </b-input-group-append>
                      </b-input-group>
                    </b-form-group>
                  </b-form-group> -->
                  <!-- <b-form-group label-cols-lg="2" label="Register Stealth Meta Address" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                    <b-form-group label="" label-for="register-keys-submit" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-button size="sm" id="register-keys-submit" @click="registerKey()" variant="warning">Register</b-button>
                    </b-form-group>
                  </b-form-group> -->
                </b-card-body>
              </b-card>

            </b-card-text>
          </b-card>
        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://sepolia.etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://sepolia.etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chains.filter(e => e.value == chainId)[0] && chains.filter(e => e.value == chainId)[0].text || ("Chain Id: " + chainId) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://sepolia.etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://sepolia.etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>StealthChad</i> &copy; Bok Consulting Pty Ltd 2023
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          CONFIRMATIONS: 100,
          DBPROCESSINGBATCHSIZE: 3,
          defaultPhrase: "I want to login into my stealth wallet on Ethereum mainnet.",
          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,

          forceRefresh: 0,

          stealthMetaAddress: {
            display: false,
            spendingPrivateKey: null, // TODO: Don't save this
            viewingPrivateKey: null,
          },

          settings: {
            tabIndex: 0,
            showInfo: false,
            reportingDateTime: 0,
            stealthMetaAddress: {
              message: "I want to login into my stealth wallet on Ethereum mainnet.",
              spendingPublicKey: null,
              viewingPublicKey: null,
              stealthMetaAddress: null,
            },
            transfer: {
              recipientStealthMetaAddress: null,
              amount: 0.01,
            },
            activityTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'txorderdsc',
            },
            addressesTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'eoaasc',
            },
            contractsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'typenameasc',
            },
            registryActivityTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'txorderdsc',
            },
            accountsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'typenameasc',
            },
            version: 23,
          },
          contracts: {
            "11155111": {
              "0x4f58404F363f8a3282648E80440e075e5C1E28a1": {
                "type": "announcer",
                "name": "ERC5564Announcer on Sepolia",
                "read": true,
                "write": false,
                "blockNumber": 4959070,
                "timestamp": 1703564424
              },
              "0x3834bcA9093e375893D65975ad765179A149D017": {
                "type": "caller",
                "name": "StealthChad v0.8.0 on Sepolia",
                "read": true,
                "write": true,
                "blockNumber": 4959070,
                "timestamp": 1703564424
              },
              "0xC5F111011acAd96860a3cd3d7C50Dd8f56a5684e": {
                "type": "registry",
                "name": "ERC5564Registry v0.8.0 on Sepolia",
                "read": true,
                "write": true,
                "blockNumber": 4960971,
                "timestamp": 1703590932
              }
            }
          },
          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },

          announcements: [],
          registryEntries: [],
          accounts: {},

          events: {},
          registryEvents: {},
          addresses: { // TODO: Add ENS field for production
            // "11155111": {
            //   "0x000001f568875F378Bf6d170B790967FE429C81A": {
            //     name: "My Account",
            //     stealthMetaAddresses: {
            //       "st:eth:0x039441d882d0cf33565dda9c752910f9bb13186555495c081e9d33e391518456c403ea8baab0486a7b4b6056d77e35a8f0b5534550fdfe53a69180885ea10fbecb96": {
            //         stealthMetaAddressName: "My First Stealth Meta-Account",
            //         phrase: "I want to login into my stealth wallet on Ethereum mainnet.",
            //       },
            //       "st:eth:0x027aa1f6cd1760c20a333c564230681e2a08abe03b80b142eb187a39e1d2a00dd402d142d4eb630301a9d0bf8e18e673d89d4dd749190b2264979da7ec869b0dc3e1": {
            //         stealthMetaAddressName: "My Second Stealth Meta-Account",
            //         phrase: "I want to login into my stealth wallet on Ethereum mainnet.1",
            //       }
            //     }
            //   },
            //   "0x5d446D064757Cc92eFe92548F2D7b7a3eab30362": {
            //     name: "My Sepolia Testing Account",
            //     stealthMetaAddresses: {
            //       "st:eth:0x03db0fb987c911ac999e54061ed812f3a74357373afd828a30df8b79bbfef13dd30358e291c3a8935e479ad66e2894b1ff235e1e60b0426187ed1f4082476a4b68c4": {
            //         stealthMetaAddressName: "My Third Stealth Meta-Account",
            //         phrase: "I want to login into my stealth wallet on Ethereum mainnet.",
            //       }
            //     }
            //   },
            // }
          },
          blockTimestamps: {},
          txs: {},
          modalAccount: {
            source: null,
            item: null,
            name: null,
          },
          modalActivity: {
            item: null,
          },
          modalApproval: {
            item: null,
            tokens: null, // ERC-20 Approval
            spender: null, // ERC-721 Approval
            tokenId: null, // ERC-721 Approval
            approved: false, // ERC-721 & ERC-1155 ApprovalForAll
          },
          modalNewStealthMetaAddressNew: {
            name: null,
            linkedTo: null,
            phrase: null,
            viewingPrivateKey: null,
            spendingPublicKey: null,
            viewingPublicKey: null,
            stealthMetaAddress: null,
            status: null,
          },
          modalNewStealthMetaAddress: {
            phrase: null,
            name: null,
            stealthMetaAddressName: null,
            keys: {},
          },
          modalAddress: {
            item: null,
          },
          modalRegistry: {
            item: null,
          },
          modalContract: {
            item: null,
            name: null,
            read: false,
            write: false,
          },
          chains: [
            { value: 1, text: 'Ethereum Mainnet' },
            { value: 11155111, text: 'Sepolia Testnet' },
          ],
          contractTypeOptions: [
            { value: null, text: '(select)' },
            { value: "announcer", text: 'ERC-5564 Announcer' },
            { value: "registry", text: 'ERC-6538 Registry' },
            { value: "caller", text: 'ERC-5564 Caller' },
          ],
          activitySortOptions: [
            { value: 'txorderasc', text: '▲ TxOrder' },
            { value: 'txorderdsc', text: '▼ TxOrder' },
          ],
          addressesSortOptions: [
            { value: 'eoaasc', text: '▲ EOA' },
            { value: 'eoadsc', text: '▼ EOA' },
          ],
          registryActivitySortOptions: [
            { value: 'txorderasc', text: '▲ TxOrder' },
            { value: 'txorderdsc', text: '▼ TxOrder' },
          ],
          contractsSortOptions: [
            { value: 'typenameasc', text: '▲ Type, ▲ Name' },
            { value: 'typenamedsc', text: '▼ Type, ▼ Name' },
            { value: 'nameasc', text: '▲ Name, ▲ Address' },
            { value: 'namedsc', text: '▼ Name, ▼ Address' },
          ],
          accountsSortOptions: [
            { value: 'typenameasc', text: '▲ Type, ▲ Name' },
            { value: 'typenamedsc', text: '▼ Type, ▼ Name' },
            { value: 'nameasc', text: '▲ Name' },
            { value: 'namedsc', text: '▼ Name' },
            { value: 'addressasc', text: '▲ Address' },
            { value: 'addressdsc', text: '▼ Address' },
          ],
          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],
          falseTrueOptions: [
            { value: false, text: 'false' },
            { value: true, text: 'true' },
          ],
          accountTypeOptions: [
            { value: null, text: '(use default)' },
            { value: "eoa", text: 'EOA' },
            { value: "erc20", text: 'ERC-20' },
            { value: "erc721", text: 'ERC-721' },
            { value: "erc1155", text: 'ERC-1155' },
            { value: "ftexchange", text: 'FTExchange' },
            { value: "nftexchange", text: 'NFTExchange' },
            { value: "unknown", text: '(Unknown)' },
          ],
          decimalsOptions: [
            { value: null, text: '(use default)' },
            { value: "0", text: '0' },
            { value: "1", text: '1' },
            { value: "2", text: '2' },
            { value: "3", text: '3' },
            { value: "4", text: '4' },
            { value: "5", text: '5' },
            { value: "6", text: '6 (some)' },
            { value: "7", text: '7' },
            { value: "8", text: '8' },
            { value: "9", text: '9' },
            { value: "10", text: '10' },
            { value: "11", text: '11' },
            { value: "12", text: '12' },
            { value: "13", text: '13' },
            { value: "14", text: '14' },
            { value: "15", text: '15' },
            { value: "16", text: '16' },
            { value: "17", text: '17' },
            { value: "18", text: '18 (common)' },
          ],
          activityFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            // { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'sender', label: 'Sender', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'receiver', label: 'Receiver', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'details', label: 'Details', sortable: false, thStyle: 'width: 55%;', thClass: 'text-left', tdClass: 'text-left' },
            // { key: 'owner', label: 'Owner', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'spender', label: 'Spender', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'approved', label: 'Approved', /*sortable: true,*/ thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          addressesFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            // { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'accountName', label: 'Account Name', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'stealthMetaAddress', label: 'Stealth Meta-Address', sortable: false, thStyle: 'width: 35%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'stealthMetaAddressName', label: 'Stealth Meta-Address Name', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'schemeId', label: 'Scheme Id', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'stealthMetaAddress', label: 'Stealth Meta-Address', sortable: false, thStyle: 'width: 55%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          registryActivityFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'registrant', label: 'Registrant', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'schemeId', label: 'Scheme Id', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'stealthMetaAddress', label: 'Stealth Meta-Address', sortable: false, thStyle: 'width: 55%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          accountsFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'linkedTo', label: 'Linked To', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'source', label: 'Source', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'mine', label: 'Mine', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 35%;', thClass: 'text-left', tdClass: 'text-truncate' },
          ],
          contractsFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'chainId', label: 'Chain', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'contract', label: 'Contract', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'read', label: 'Read', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'write', label: 'Write', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'firstEvent', label: 'First Event', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
          ],
          reportingDateTimeOptions: [
            { value: 0, text: 'Local Time' },
            { value: 1, text: 'UTC Time' },
          ],
          db: {
            name: "stealthchaddata080f",
            version: 1,
            schemaDefinition: {
              // cache: '&objectName',
              // syncStates: '&contract',
              announcements: '[chainId+blockNumber+logIndex],[blockNumber+contract],contract,confirmations',
              registryEntries: '[chainId+blockNumber+logIndex],[blockNumber+contract],contract,confirmations',
              // txs: '[blockNumber+txIndex],txHash',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {
          filteredActivity() {
            return this.announcements.filter(e => e.chainId == this.chainId);
          },
          filteredSortedActivity() {
            let results = this.filteredActivity;
            if (this.settings.activityTable.sortOption == 'txorderasc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return a.logIndex - b.logIndex;
                  } else {
                    return a.txIndex - b.txIndex;
                  }
                } else {
                  return a.blockNumber - b.blockNumber;
                }
              });
            } else if (this.settings.activityTable.sortOption == 'txorderdsc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return b.logIndex - a.logIndex;
                  } else {
                    return b.txIndex - a.txIndex;
                  }
                } else {
                  return b.blockNumber - a.blockNumber;
                }
              });
            }
            return results;
          },
          pagedFilteredSortedActivity() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedActivity - results[0..9]: " + JSON.stringify(this.filteredSortedActivity.slice(0, 10), null, 2));
            return this.filteredSortedActivity.slice((this.settings.activityTable.currentPage - 1) * this.settings.activityTable.pageSize, this.settings.activityTable.currentPage * this.settings.activityTable.pageSize);
          },

          filteredRegistryActivity() {
            return this.registryEntries.filter(e => e.chainId == this.chainId);
          },
          filteredSortedRegistryActivity() {
            let results = this.filteredRegistryActivity;
            if (this.settings.registryActivityTable.sortOption == 'txorderasc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return a.logIndex - b.logIndex;
                  } else {
                    return a.txIndex - b.txIndex;
                  }
                } else {
                  return a.blockNumber - b.blockNumber;
                }
              });
            } else if (this.settings.registryActivityTable.sortOption == 'txorderdsc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return b.logIndex - a.logIndex;
                  } else {
                    return b.txIndex - a.txIndex;
                  }
                } else {
                  return b.blockNumber - a.blockNumber;
                }
              });
            }
            return results;
          },
          pagedFilteredSortedRegistryActivity() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedRegistryActivity - results[0..9]: " + JSON.stringify(this.filteredSortedRegistryActivity.slice(0, 10), null, 2));
            return this.filteredSortedRegistryActivity.slice((this.settings.registryActivityTable.currentPage - 1) * this.settings.registryActivityTable.pageSize, this.settings.registryActivityTable.currentPage * this.settings.registryActivityTable.pageSize);
          },

          totalAddresses() {
            let result = this.forceRefresh % 2 == 0 ? 0 : 0;
            const addresses = this.addresses[this.chainId] || {};
            for (const [address, accountData] of Object.entries(addresses)) {
              for (const [stealthMetaAddress, stealthMetaAddressData] of Object.entries(accountData.stealthMetaAddresses)) {
                result++;
              }
            }
            return result;
          },
          filteredAddresses() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            const addresses = this.addresses[this.chainId] || {};
            for (const [address, accountData] of Object.entries(addresses)) {
              // console.log(address + " => " + JSON.stringify(accountData));
              for (const [stealthMetaAddress, stealthMetaAddressData] of Object.entries(accountData.stealthMetaAddresses)) {
                results.push({ address, accountName: accountData.name, ensName: accountData.ensName, stealthMetaAddress, ...stealthMetaAddressData })
              }
            }
            return results;
          },
          filteredSortedAddresses() {
            let results = this.filteredAddresses;
            if (this.settings.addressesTable.sortOption == 'typenameasc') {
              results.sort((a, b) => {
                const typeA = a.customType || a.type;
                const typeB = b.customType || b.type;
                const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
                const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
                if (sortIndexA == sortIndexB) {
                  const namea = a.customName || a.name;
                  const nameb = b.customName || b.name;
                  return ('' + namea).localeCompare(nameb);
                } else {
                  return sortIndexA - sortIndexB;
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'typenamedsc') {
              results.sort((a, b) => {
                const typeA = a.customType || a.type;
                const typeB = b.customType || b.type;
                const sortIndexA = this.accountTypeOptions.findIndex(e => e.value == typeA);
                const sortIndexB = this.accountTypeOptions.findIndex(e => e.value == typeB);
                if (sortIndexA == sortIndexB) {
                  const namea = a.customName || a.name;
                  const nameb = b.customName || b.name;
                  return ('' + nameb).localeCompare(namea);
                } else {
                  return sortIndexB - sortIndexA;
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                return ('' + a.name).localeCompare(b.name);
              });
            } else if (this.settings.addressesTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                return ('' + b.name).localeCompare(a.name);
              });
            } else if (this.settings.addressesTable.sortOption == 'addressasc') {
              results.sort((a, b) => {
                return ('' + a.address).localeCompare(b.address);
              });
            } else if (this.settings.addressesTable.sortOption == 'addressdsc') {
              results.sort((a, b) => {
                return ('' + b.address).localeCompare(a.address);
              });
            }
            return results;
          },
          pagedFilteredSortedAddresses() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedAddresses - results[0..9]: " + JSON.stringify(this.filteredSortedAddresses.slice(0, 10), null, 2));
            return this.filteredSortedAddresses.slice((this.settings.addressesTable.currentPage - 1) * this.settings.addressesTable.pageSize, this.settings.addressesTable.currentPage * this.settings.addressesTable.pageSize);
          },

          totalContracts() {
            let result = this.forceRefresh % 2 == 0 ? 0 : 0;
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                result++;
              }
            }
            return result;
          },
          filteredContracts() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                const contractTypeSortIndex = this.contractTypeOptions.findIndex(e => e.value == contractData.type);
                results.push({ chainId, contract, ...contractData, contractTypeSortIndex });
              }
            }
            return results;
          },
          filteredSortedContracts() {
            // TODO: Sort options 3 and 4 a bit buggy
            let results = this.filteredContracts;
            if (this.settings.contractsTable.sortOption == 'typenameasc') {
              results.sort((a, b) => {
                if (a.contractTypeSortIndex == b.contractTypeSortIndex) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.contract).localeCompare(b.contract);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return a.contractTypeSortIndex - b.contractTypeSortIndex;
                }
              });
            } else if (this.settings.contractsTable.sortOption == 'typenamedsc') {
              results.sort((a, b) => {
                if (a.contractTypeSortIndex == b.contractTypeSortIndex) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + b.contract).localeCompare(a.contract);
                  } else {
                    return ('' + b.name).localeCompare(a.name);
                  }
                } else {
                  return b.contractTypeSortIndex - a.contractTypeSortIndex;
                }
              });
            } else if (this.settings.contractsTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + a.contract).localeCompare(b.contract);
                } else {
                  return ('' + a.name).localeCompare(b.name);
                }
              });
            } else if (this.settings.contractsTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + b.contract).localeCompare(a.contract);
                } else {
                  return ('' + b.name).localeCompare(a.name);
                }
              });
            }
            return results;
          },
          pagedFilteredSortedContracts() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedContracts - results[0..9]: " + JSON.stringify(this.filteredSortedContracts.slice(0, 10), null, 2));
            return this.filteredSortedContracts.slice((this.settings.activityTable.currentPage - 1) * this.settings.activityTable.pageSize, this.settings.activityTable.currentPage * this.settings.activityTable.pageSize);
          },

          totalAccounts() {
            let result = this.forceRefresh % 2 == 0 ? 0 : 0;
            for (const [address, accountData] of Object.entries(this.accounts)) {
              result++;
            }
            return result;
          },
          filteredAccounts() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            for (const [address, accountData] of Object.entries(this.accounts)) {
              results.push({ address, ...accountData });
            }
            return results;
          },
          filteredSortedAccounts() {
            let results = this.filteredAccounts;
            // TODO
            if (this.settings.accountsTable.sortOption == 'typenameasc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  return ('' + a.name).localeCompare(b.name);
                } else {
                  return ('' + b.type).localeCompare(a.type);
                }
              });
            } else if (this.settings.accountsTable.sortOption == 'typenamedsc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  return ('' + b.name).localeCompare(a.name);
                } else {
                  return ('' + a.type).localeCompare(b.type);
                }
              });
            } else if (this.settings.accountsTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                return ('' + a.name).localeCompare(b.name);
              });
            } else if (this.settings.accountsTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                return ('' + b.name).localeCompare(a.name);
              });
            } else if (this.settings.accountsTable.sortOption == 'addressasc') {
              results.sort((a, b) => {
                return ('' + a.address).localeCompare(b.address);
              });
            } else if (this.settings.accountsTable.sortOption == 'addressdsc') {
              results.sort((a, b) => {
                return ('' + b.address).localeCompare(a.address);
              });
            }
            return results;
          },
          pagedFilteredSortedAccounts() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedAccounts - results[0..9]: " + JSON.stringify(this.filteredSortedAccounts.slice(0, 10), null, 2));
            return this.filteredSortedAccounts.slice((this.settings.accountsTable.currentPage - 1) * this.settings.accountsTable.pageSize, this.settings.accountsTable.currentPage * this.settings.accountsTable.pageSize);
          },
        },

        // --- METHODS ---
        methods: {

          async searchForContracts() {
            // Announcement (index_topic_1 uint256 schemeId, index_topic_2 address stealthAddress, index_topic_3 address caller, bytes ephemeralPublicKey, bytes metadata)
            // 0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7
            // Note: Following is ERC-6538: Stealth Meta-Address Registry with registrant being bytes32 instead of bytes
            // StealthMetaAddressSet (index_topic_1 bytes32 registrant, index_topic_2 uint256 scheme, bytes stealthMetaAddress)
            // 0x0bb4b5456abb9a4e7e0624d821e95e2fcc8a761c9227b5d761ae0da4a3fda233
            console.log(moment().format("HH:mm:ss") + " searchForContracts");
            const contractsMap = {};
            let total = 0;
            function processLogs(fromBlock, toBlock, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " searchForContracts.processLogs: " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
              for (const event of logs) {
                if (!event.removed) {
                  if (event.topics[0] == "0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7") {
                    const caller = ethers.utils.getAddress("0x" + event.topics[3].substring(26, 66));
                    if (!(event.address in contractsMap)) {
                      contractsMap[event.address] = { type: "announcer", blockNumber: event.blockNumber };
                    }
                    if (!(caller in contractsMap)) {
                      contractsMap[caller] = { type: "caller", blockNumber: event.blockNumber };
                    }
                  } else {
                    if (!(event.address in contractsMap)) {
                      contractsMap[event.address] = { type: "registry", blockNumber: event.blockNumber };
                    }
                  }
                }
              }
            }
            async function getLogs(fromBlock, toBlock, processLogs) {
              try {
                const filter = {
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [
                    ['0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7', '0x0bb4b5456abb9a4e7e0624d821e95e2fcc8a761c9227b5d761ae0da4a3fda233'],
                    null,
                    null
                  ]
                };
                const eventLogs = await provider.getLogs(filter);
                processLogs(fromBlock, toBlock, eventLogs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, processLogs);
              }
            }
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.coinbase = await signer.getAddress();
            localStorage.stealthChadCoinbase = this.coinbase;
            const network = await provider.getNetwork();
            localStorage.stealthChadChainId = network.chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " searchForContracts - latestBlockNumber: " + latestBlockNumber + ", chainId: " + this.chainId);
            const startBlock = 0;
            await getLogs(startBlock, latestBlockNumber, processLogs);
            const contracts = this.contracts;
            if (!(this.chainId in contracts)) {
              contracts[this.chainId] = {};
            }
            for (const [contract, data] of Object.entries(contractsMap)) {
              const type = data.type;
              const blockNumber = data.blockNumber;
              const timestamp = (await provider.getBlock(blockNumber)).timestamp
              const customData = CUSTOMNAMES[contract] || {};
              contracts[this.chainId][contract] = { type, name: customData.name || null, read: customData.read || false, write: customData.write || false, blockNumber, timestamp };
            }
            Vue.set(this, 'contracts', contracts);
            localStorage.stealthChadContracts = JSON.stringify(this.contracts);
          },

          saveModalContractName() {
            console.log(moment().format("HH:mm:ss") + " saveModalContractName: " + JSON.stringify(this.modalContract));
            this.modalContract.item.name = this.modalContract.name;
            Vue.set(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], 'name', this.modalContract.name);
            localStorage.stealthChadContracts = JSON.stringify(this.contracts);
            // console.log(moment().format("HH:mm:ss") + " saveModalContractName - contracts: " + JSON.stringify(this.contracts, null, 2));
          },
          // TODO: Low priority - toggleContractRead & toggleContractWrite do not update correctly for newly scanned contracts
          toggleContractRead(item) {
            // console.log(moment().format("HH:mm:ss") + " toggleContractRead");
            if (this.modalContract.item && this.modalContract.item.chainId && this.modalContract.item.contract) {
              Vue.set(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], 'read', !this.modalContract.read);
              localStorage.stealthChadContracts = JSON.stringify(this.contracts);
              // console.log(moment().format("HH:mm:ss") + " AFTER: " + JSON.stringify(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], null, 2));
            }
          },
          toggleContractWrite(item) {
            // console.log(moment().format("HH:mm:ss") + " toggleContractWrite");
            if (this.modalContract.item && this.modalContract.item.chainId && this.modalContract.item.contract) {
              Vue.set(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], 'write', !this.modalContract.write);
              localStorage.stealthChadContracts = JSON.stringify(this.contracts);
              // console.log(moment().format("HH:mm:ss") + " AFTER: " + JSON.stringify(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], null, 2));
            }
          },

          newStealthMetaAddressNew() {
            console.log(moment().format("HH:mm:ss") + " newStealthMetaAddressNew");
            this.modalNewStealthMetaAddressNew.name = null;
            this.modalNewStealthMetaAddressNew.linkedTo = this.coinbase;
            this.modalNewStealthMetaAddressNew.phrase = this.defaultPhrase;
            this.modalNewStealthMetaAddressNew.viewingPrivateKey = null;
            this.modalNewStealthMetaAddressNew.spendingPublicKey = null;
            this.modalNewStealthMetaAddressNew.viewingPublicKey = null;
            this.modalNewStealthMetaAddressNew.stealthMetaAddress = null;
            this.modalNewStealthMetaAddressNew.status = null;
            this.$bvModal.show('modal-newstealthmetaaddressnew');
          },

          newStealthMetaAddress() {
            console.log(moment().format("HH:mm:ss") + " newStealthMetaAddress");
            this.modalNewStealthMetaAddress.phrase = this.defaultPhrase;

            this.modalNewStealthMetaAddress.name = null;
            const addresses = this.addresses[this.chainId] || {};
            for (const [address, accountData] of Object.entries(addresses)) {
              // console.log(address + " => " + JSON.stringify(accountData));
              for (const [stealthMetaAddress, stealthMetaAddressData] of Object.entries(accountData.stealthMetaAddresses)) {
                // console.log({ address, accountName: accountData.name, stealthMetaAddress, ...stealthMetaAddressData })
                if (address == this.coinbase && !this.modalNewStealthMetaAddress.name) {
                  this.modalNewStealthMetaAddress.name = accountData.name;
                }
              }
            }

            // TODO: Testing
            this.modalNewStealthMetaAddress.keys = {
              // "spendingPrivateKey": "0x3795c0f4e8bda3b59b249eb3e64a8b3235ab29531fc83809a134b22d30c31cda",
              // "viewingPrivateKey": "0xb8293d4764cb158b9e395e3aed255d588c8e3380e0798921446d8735eecced91",
              // "spendingPublicKey": "0x037772573d8d959eaf076128f467c81083063d0f333ad77b59f04ab7d4a927d6b5",
              // "viewingPublicKey": "0x03daab8862af2ba106420b20fdc62278281544fa20256d65f13ab19fc5d5d6bd44",
              // "stealthMetaAddress": "st:eth:0x037772573d8d959eaf076128f467c81083063d0f333ad77b59f04ab7d4a927d6b503daab8862af2ba106420b20fdc62278281544fa20256d65f13ab19fc5d5d6bd44",
              // "inAddressBook": false,
              // "inRegistry": false,
            };
            this.$bvModal.show('modal-newstealthmetaaddress');
          },

          async generateNewStealthMetaAddressNew() {
            console.log(moment().format("HH:mm:ss") + " generateNewStealthMetaAddressNew - phrase: " + this.modalNewStealthMetaAddress.phrase);
            const phraseInHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(this.modalNewStealthMetaAddressNew.phrase));
            // console.log(moment().format("HH:mm:ss") + " generateKeys - phraseInHex: " + phraseInHex);
            const signature = await ethereum.request({
                method: 'personal_sign',
                params: [phraseInHex, this.coinbase],
            });
            const signature1 = signature.slice(2, 66);
            const signature2 = signature.slice(66, 130);
            // Hash "v" and "r" values using SHA-256
            const hashedV = ethers.utils.sha256("0x" + signature1);
            const hashedR = ethers.utils.sha256("0x" + signature2);
            const n = ethers.BigNumber.from('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
            // Calculate the private keys by taking the hash values modulo the curve order
            const privateKey1 = ethers.BigNumber.from(hashedV).mod(n);
            const privateKey2 = ethers.BigNumber.from(hashedR).mod(n);
            const keyPair1 = new ethers.Wallet(privateKey1.toHexString());
            const keyPair2 = new ethers.Wallet(privateKey2.toHexString());
            // Vue.set(this.modalNewStealthMetaAddress.keys, 'spendingPrivateKey', keyPair1.privateKey);
            Vue.set(this.modalNewStealthMetaAddressNew, 'viewingPrivateKey', keyPair2.privateKey);
            const spendingPublicKey = ethers.utils.computePublicKey(keyPair1.privateKey, true);
            const viewingPublicKey = ethers.utils.computePublicKey(keyPair2.privateKey, true);
            const stealthMetaAddress = "st:eth:" + spendingPublicKey + viewingPublicKey.substring(2);
            Vue.set(this.modalNewStealthMetaAddressNew, 'spendingPublicKey', spendingPublicKey);
            Vue.set(this.modalNewStealthMetaAddressNew, 'viewingPublicKey', viewingPublicKey);
            Vue.set(this.modalNewStealthMetaAddressNew, 'stealthMetaAddress', stealthMetaAddress);
            Vue.set(this.modalNewStealthMetaAddressNew, 'linkedTo', this.coinbase);

            let status;
            if (stealthMetaAddress in this.accounts) {
              status = this.accounts[stealthMetaAddress].mine ? "mine" : "notmine";
            } else {
              status = "doesnotexist";
            }
            Vue.set(this.modalNewStealthMetaAddressNew, 'status', status);
            console.log("this.modalNewStealthMetaAddressNew: " + JSON.stringify(this.modalNewStealthMetaAddressNew, null, 2));
          },


          async generateNewStealthMetaAddress() {
            console.log(moment().format("HH:mm:ss") + " generateNewStealthMetaAddress - phrase: " + this.modalNewStealthMetaAddress.phrase);
            const phraseInHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(this.modalNewStealthMetaAddress.phrase));
            // console.log(moment().format("HH:mm:ss") + " generateKeys - phraseInHex: " + phraseInHex);
            const signature = await ethereum.request({
                method: 'personal_sign',
                params: [phraseInHex, this.coinbase],
            });
            // console.log("signature: " + signature);
            const signature1 = signature.slice(2, 66);
            const signature2 = signature.slice(66, 130);
            // console.log("signature1: " + signature1);
            // console.log("signature2: " + signature2);
            // Hash "v" and "r" values using SHA-256
            const hashedV = ethers.utils.sha256("0x" + signature1);
            const hashedR = ethers.utils.sha256("0x" + signature2);
            const n = ethers.BigNumber.from('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
            // console.log("hashedV: " + hashedV);
            // console.log("hashedR: " + hashedR);
            // // Calculate the private keys by taking the hash values modulo the curve order
            const privateKey1 = ethers.BigNumber.from(hashedV).mod(n);
            const privateKey2 = ethers.BigNumber.from(hashedR).mod(n);
            const keyPair1 = new ethers.Wallet(privateKey1.toHexString());
            const keyPair2 = new ethers.Wallet(privateKey2.toHexString());
            Vue.set(this.modalNewStealthMetaAddress.keys, 'spendingPrivateKey', keyPair1.privateKey);
            Vue.set(this.modalNewStealthMetaAddress.keys, 'viewingPrivateKey', keyPair2.privateKey);
            const spendingPublicKey = ethers.utils.computePublicKey(keyPair1.privateKey, true);
            const viewingPublicKey = ethers.utils.computePublicKey(keyPair2.privateKey, true);
            const stealthMetaAddress = "st:eth:" + spendingPublicKey + viewingPublicKey.substring(2);
            Vue.set(this.modalNewStealthMetaAddress.keys, 'spendingPublicKey', spendingPublicKey);
            Vue.set(this.modalNewStealthMetaAddress.keys, 'viewingPublicKey', viewingPublicKey);
            Vue.set(this.modalNewStealthMetaAddress.keys, 'stealthMetaAddress', stealthMetaAddress);
            let inAddressBook = false;
            const addresses = this.addresses[this.chainId] || {};
            for (const [address, accountData] of Object.entries(addresses)) {
              console.log(address + " => " + JSON.stringify(accountData));
              for (const [checkStealthMetaAddress, checkStealthMetaAddressData] of Object.entries(accountData.stealthMetaAddresses)) {
                if (checkStealthMetaAddress == stealthMetaAddress) {
                  inAddressBook = true;
                  break;
                }
              }
              if (inAddressBook) {
                break;
              }
            }
            let inRegistry = false;
            const registryEvents = this.registryEvents[this.chainId] || {};
            for (const blockNumber of Object.keys(registryEvents).sort((a, b) => { return a - b })) {
              const blockNumberData = registryEvents[blockNumber];
              for (const logIndex of Object.keys(blockNumberData).sort((a, b) => { return a - b })) {
                const eventData = registryEvents[blockNumber][logIndex];
                if (eventData.stealthMetaAddress == stealthMetaAddress) {
                  inRegistry = true;
                  break;
                }
              }
              if (inRegistry) {
                break;
              }
            }
            Vue.set(this.modalNewStealthMetaAddress.keys, 'inAddressBook', inAddressBook);
            Vue.set(this.modalNewStealthMetaAddress.keys, 'inRegistry', inRegistry);
            console.log("this.modalNewStealthMetaAddress.keys: " + JSON.stringify(this.modalNewStealthMetaAddress.keys, null, 2));
          },
          updateModalAccountName() {
            console.log(moment().format("HH:mm:ss") + " updateModalAccountName from: " + (this.modalAccount.item && this.modalAccount.item.name || "(null)") + ", to: " + this.modalAccount.name);
            if (!(this.chainId in this.addresses)) {
              Vue.set(this.addresses, this.chainId, {});
            }
            console.log("addresses: " + JSON.stringify(Object.keys(this.addresses[this.chainId])));
            if (!(this.modalAccount.item.address in this.addresses[this.chainId])) {
              Vue.set(this.addresses[this.chainId], this.modalAccount.item.address, { name: this.modalAccount.name, ensName: null, source: this.modalAccount.source, stealthMetaAddresses: {} });
            } else {
              Vue.set(this.addresses[this.chainId][this.modalAccount.item.address], 'name', this.modalAccount.name);
            }
            Vue.set(this.modalAccount.item, 'name', this.modalAccount.name);
            localStorage.stealthChadAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " updateModalAccountName - addresses: " + JSON.stringify(this.addresses, null, 2));
          },

          addStealthMetaAddressToAddressBookNew() {
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToAddressBookNew");
            const account = this.accounts[this.modalNewStealthMetaAddressNew.stealthMetaAddress];
            if (account) {
              account.type = "stealthMetaAddress";
              account.name = this.modalNewStealthMetaAddressNew.name;
              account.linkedTo = this.modalNewStealthMetaAddressNew.linkedTo;
              account.phrase = this.modalNewStealthMetaAddressNew.phrase;
              account.viewingPrivateKey = this.modalNewStealthMetaAddressNew.viewingPrivateKey;
              account.spendingPublicKey = this.modalNewStealthMetaAddressNew.spendingPublicKey;
              account.viewingPublicKey = this.modalNewStealthMetaAddressNew.viewingPublicKey;
              account.mine = true;
              Vue.set(this.accounts, this.modalNewStealthMetaAddressNew.stealthMetaAddress, account);
            } else {
              Vue.set(this.accounts, this.modalNewStealthMetaAddressNew.stealthMetaAddress, {
                type: "stealthMetaAddress",
                name: this.modalNewStealthMetaAddressNew.name,
                linkedTo: this.modalNewStealthMetaAddressNew.linkedTo,
                phrase: this.modalNewStealthMetaAddressNew.phrase,
                viewingPrivateKey: this.modalNewStealthMetaAddressNew.viewingPrivateKey,
                spendingPublicKey: this.modalNewStealthMetaAddressNew.spendingPublicKey,
                viewingPublicKey: this.modalNewStealthMetaAddressNew.viewingPublicKey,
                mine: true,
                source: "user.signed",
              });
            }
            localStorage.stealthChadAccounts = JSON.stringify(this.accounts);
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToAddressBookNew - accounts: " + JSON.stringify(this.accounts, null, 2));
          },
          addStealthMetaAddressToAddressBook() {
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToAddressBook");
            const addresses = this.addresses[this.chainId] || {};
            if (!(this.chainId in this.addresses)) {
              Vue.set(this.addresses, this.chainId, {});
            }
            if (!(this.coinbase in addresses)) {
              Vue.set(this.addresses[this.chainId], this.coinbase, { name: this.modalNewStealthMetaAddress.name, ensName: null, stealthMetaAddresses: {} });
            } else {
              Vue.set(this.addresses[this.chainId][this.coinbase], 'name', this.modalNewStealthMetaAddress.name);
            }
            console.log("this.modalNewStealthMetaAddress: " + JSON.stringify(this.modalNewStealthMetaAddress, null, 2));
            Vue.set(this.addresses[this.chainId][this.coinbase].stealthMetaAddresses, this.modalNewStealthMetaAddress.keys.stealthMetaAddress, {
              phrase:  this.modalNewStealthMetaAddress.phrase,
              stealthMetaAddressName: this.modalNewStealthMetaAddress.stealthMetaAddressName,
              // TODO: Handle private keys securely
              spendingPrivateKey: this.modalNewStealthMetaAddress.keys.spendingPrivateKey,
              viewingPrivateKey: this.modalNewStealthMetaAddress.keys.viewingPrivateKey,
              spendingPublicKey: this.modalNewStealthMetaAddress.keys.spendingPublicKey,
              viewingPublicKey: this.modalNewStealthMetaAddress.keys.viewingPublicKey,
            });
            localStorage.stealthChadAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToAddressBook - addresses: " + JSON.stringify(this.addresses, null, 2));
          },
          addStealthMetaAddressToRegistry() {
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToRegistry");
          },
          async generateKeys() {
            // https://github.com/nerolation/stealth-wallet/blob/main/scripts/website_logic.js#L230
            console.log(moment().format("HH:mm:ss") + " generateKeys - message: " + this.settings.stealthMetaAddress.message);
            const hexValue = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(this.settings.stealthMetaAddress.message));
            console.log(moment().format("HH:mm:ss") + " generateKeys - hexValue: " + hexValue);

            const signature = await ethereum.request({
                method: 'personal_sign',
                params: [hexValue, this.coinbase],
            });
            console.log("signature: " + signature);
            const signature1 = signature.slice(2, 66);
            const signature2 = signature.slice(66, 130);
            console.log("signature1: " + signature1);
            console.log("signature2: " + signature2);

            // Hash "v" and "r" values using SHA-256
            const hashedV = ethers.utils.sha256("0x" + signature1);
            const hashedR = ethers.utils.sha256("0x" + signature2);
            const n = ethers.BigNumber.from('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
            console.log("hashedV: " + hashedV);
            console.log("hashedR: " + hashedR);

            // // Calculate the private keys by taking the hash values modulo the curve order
            const privateKey1 = ethers.BigNumber.from(hashedV).mod(n);
            const privateKey2 = ethers.BigNumber.from(hashedR).mod(n);
            const keyPair1 = new ethers.Wallet(privateKey1.toHexString());
            const keyPair2 = new ethers.Wallet(privateKey2.toHexString());
            this.stealthMetaAddress.spendingPrivateKey = keyPair1.privateKey;
            this.stealthMetaAddress.viewingPrivateKey = keyPair2.privateKey;

            console.log("this.stealthMetaAddress.spendingPrivateKey: " + this.stealthMetaAddress.spendingPrivateKey);
            console.log("this.stealthMetaAddress.viewingPrivateKey: " + this.stealthMetaAddress.viewingPrivateKey);

            this.settings.stealthMetaAddress.spendingPublicKey = ethers.utils.computePublicKey(keyPair1.privateKey, true);
            this.settings.stealthMetaAddress.viewingPublicKey = ethers.utils.computePublicKey(keyPair2.privateKey, true);

            this.settings.stealthMetaAddress.stealthMetaAddress = "st:eth:" + this.settings.stealthMetaAddress.spendingPublicKey + this.settings.stealthMetaAddress.viewingPublicKey.substring(2);
            this.saveSettings();
          },

          async registerKey() {
            console.log(moment().format("HH:mm:ss") + " registerKey BEGIN");
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const contract = new ethers.Contract(ERC5564REGISTRYADDRESS_SEPOLIA, ERC5564REGISTRYABI_SEPOLIA, provider);
            const contractWithSigner = contract.connect(provider.getSigner());
            const schemeId = 0;
            try {
              const stealthMetaAddress = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(this.settings.stealthMetaAddress.stealthMetaAddress));
              const tx = await contractWithSigner.registerKeys(schemeId, stealthMetaAddress);
              console.log("tx: " + JSON.stringify(tx));
            } catch (e) {
              console.log("registerKey ERC5564Registry.registerKeys(...) error: " + JSON.stringify(e));
            }
            console.log(moment().format("HH:mm:ss") + " registerKey END");
          },

          async transferEthToStealthMetaAddress() {
            function generateStealthAddress(stealthMetaAddress) {
                const result = {};
                result.stealthMetaAddress = stealthMetaAddress;
                result.receiverSpendingPublicKey = stealthMetaAddress.slice(9, 75);
                result.receiverViewingPublicKey = stealthMetaAddress.slice(75);
                // result.ephemeralPrivateKey = nobleCurves.secp256k1.utils.randomPrivateKey();
                // TODO: Remove after testing
                result.ephemeralPrivateKey = 26997109008263982877621605952415166666118239613620770339187915977330619367704n;
                result.ephemeralPublicKey = nobleCurves.secp256k1.getPublicKey(result.ephemeralPrivateKey, isCompressed=true);
                result.sharedSecret = nobleCurves.secp256k1.getSharedSecret(result.ephemeralPrivateKey, result.receiverViewingPublicKey, false);
                result.hashedSharedSecret = ethers.utils.keccak256(result.sharedSecret.slice(1));
                result.viewTag = "0x" + result.hashedSharedSecret.substring(2, 4);
                result.hashedSharedSecretPoint = nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(result.hashedSharedSecret.substring(2));
                result.stealthPublicKey = nobleCurves.secp256k1.ProjectivePoint.fromHex(result.receiverSpendingPublicKey).add(result.hashedSharedSecretPoint);
                result.stealthAddress = ethers.utils.computeAddress("0x" + result.stealthPublicKey.toHex(false));
                return result;
            }
            console.log(moment().format("HH:mm:ss") + " transferEthToStealthMetaAddress BEGIN");
            const result = generateStealthAddress(this.settings.transfer.recipientStealthMetaAddress);
            for (const [k, v] of Object.entries(result)) {
              console.log("    ", k, "=>", v);
            }

            // // const receiverSpendingPublicKey = nobleCurves.secp256k1.ProjectivePoint.fromHex(this.settings.transfer.recipientStealthMetaAddress.slice(9, 75));
            // const receiverSpendingPublicKey = this.settings.transfer.recipientStealthMetaAddress.slice(9, 75);
            // console.log("receiverSpendingPublicKey: " + receiverSpendingPublicKey.toString());
            // // const receiverViewingPublicKey = nobleCurves.secp256k1.ProjectivePoint.fromHex(this.settings.transfer.recipientStealthMetaAddress.slice(75));
            // const receiverViewingPublicKey = this.settings.transfer.recipientStealthMetaAddress.slice(75);
            // console.log("receiverViewingPublicKey: " + receiverViewingPublicKey.toString());
            //
            // // const ephemeralPrivateKey = nobleCurves.secp256k1.utils.randomPrivateKey();
            // // TODO: Remove after testing
            // const ephemeralPrivateKey = 26997109008263982877621605952415166666118239613620770339187915977330619367704n;
            // console.log("ephemeralPrivateKey: " + ephemeralPrivateKey.toString());
            //
            // const ephemeralPublicKey = nobleCurves.secp256k1.getPublicKey(ephemeralPrivateKey, isCompressed=true);
            // console.log("ephemeralPublicKey: " + ephemeralPublicKey.toString());
            //
            // const sharedSecret = nobleCurves.secp256k1.getSharedSecret(ephemeralPrivateKey, receiverViewingPublicKey, false);
            // console.log('sharedSecret: ', sharedSecret.toString());
            // console.log('sharedSecret.length: ', sharedSecret.length);
            // const hashedSharedSecret = ethers.utils.keccak256(sharedSecret.slice(1));
            // console.log('hashedSharedSecret: ', hashedSharedSecret.toString());
            // console.log('hashedSharedSecret.length: ', hashedSharedSecret.length);
            //
            // const viewTag = "0x" + hashedSharedSecret.substring(2, 4);
            // console.log('viewTag:', viewTag);
            //
            // const hashedSharedSecretPoint = nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(hashedSharedSecret.substring(2));
            // console.log('hashedSharedSecretPoint:', hashedSharedSecretPoint);
            // console.log('nobleCurves.secp256k1.ProjectivePoint.fromHex(receiverSpendingPublicKey):', nobleCurves.secp256k1.ProjectivePoint.fromHex(receiverSpendingPublicKey));
            // console.log('nobleCurves.secp256k1.ProjectivePoint.fromHex(receiverSpendingPublicKey).toHex():', nobleCurves.secp256k1.ProjectivePoint.fromHex(receiverSpendingPublicKey).toHex());
            //
            // const stealthPublicKey = nobleCurves.secp256k1.ProjectivePoint.fromHex(receiverSpendingPublicKey).add(hashedSharedSecretPoint);
            // console.log('stealthPublicKey:', stealthPublicKey);
            // console.log('stealthPublicKey.toHex():', stealthPublicKey.toHex(false));
            //
            // const stealthAddress = ethers.utils.computeAddress("0x" + stealthPublicKey.toHex(false));
            // console.log('stealthAddress:', stealthAddress);

            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const contract = new ethers.Contract(STEALTHCHADADDRESS_SEPOLIA, STEALTHCHADABI_SEPOLIA, provider);
            const contractWithSigner = contract.connect(provider.getSigner());
            const schemeId = 0;
            const value = ethers.utils.parseEther(this.settings.transfer.amount);
            try {
              const tx = await contractWithSigner.transferEthAndAnnounce(schemeId, result.stealthAddress, result.ephemeralPublicKey, result.viewTag, { value });
              console.log("tx: " + JSON.stringify(tx));
            } catch (e) {
              console.log("transferEthToStealthMetaAddress StealthChad.transferEthAndAnnounce(...) error: " + JSON.stringify(e));
            }
            console.log(moment().format("HH:mm:ss") + " transferEthToStealthMetaAddress END");
          },

          viewAccount(address, source) {
            console.log(moment().format("HH:mm:ss") + " viewAccount: " + address + ", source: " + source);
            this.modalAccount.source = source;
            this.modalAccount.item = { address, ...this.addresses[this.chainId][address] };
            this.modalAccount.name = this.addresses[this.chainId] && this.addresses[this.chainId][address] && this.addresses[this.chainId][address].name || null;
            this.$bvModal.show('modal-account');
          },

          activityRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " activityRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalActivity.item = item[0];
              this.$bvModal.show('modal-activity');
              this.$refs.activityTable.clearSelected();
            }
          },

          addressesRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " addressesRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalAddress.item = item[0];
              this.$bvModal.show('modal-address');
              this.$refs.addressesTable.clearSelected();
            }
          },

          registryRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " registryRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalRegistry.item = item[0];
              this.$bvModal.show('modal-registry');
              this.$refs.registryTable.clearSelected();
            }
          },

          accountsRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " accountsRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalAccount.item = item[0];
              this.$bvModal.show('modal-accountnew');
              this.$refs.accountsTable.clearSelected();
            }
          },

          contractRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " contractRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalContract.item = item[0];
              this.modalContract.name = item[0] && item[0].name || null;
              this.modalContract.read = item[0] && item[0].read || false;
              this.modalContract.write = item[0] && item[0].write || false;
              this.$bvModal.show('modal-contract');
              this.$refs.contractsTable.clearSelected();
            }
          },

          async updateApproval() {
            console.log(moment().format("HH:mm:ss") + " updateApproval: " + JSON.stringify(this.modalApproval));
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const item = this.modalApproval.item;
            if (item.type == 'erc20') {
              const contract = new ethers.Contract(item.contract, ERC20ABI, provider);
              const contractWithSigner = contract.connect(provider.getSigner());
              try {
                const tx = await contractWithSigner.approve(item.spender, ethers.utils.parseUnits(this.modalApproval.tokens, item.decimals));
                console.log("tx: " + JSON.stringify(tx));
              } catch (e) {
                console.log("updateApproval ERC-20.approve(...) error: " + JSON.stringify(e));
              }
            } else if (item.type == 'erc721' && item.approvalType == 'Approval') {
              const contract = new ethers.Contract(item.contract, ERC721ABI, provider);
              const contractWithSigner = contract.connect(provider.getSigner());
              try {
                const tx = await contractWithSigner.approve(this.modalApproval.spender, this.modalApproval.tokenId);
                console.log("tx: " + JSON.stringify(tx));
              } catch (e) {
                console.log("updateApproval ERC-721 approve(...) error: " + JSON.stringify(e));
              }
            } else if (item.type == 'erc721' && item.approvalType == 'ApprovalForAll') {
              const contract = new ethers.Contract(item.contract, ERC721ABI, provider);
              const contractWithSigner = contract.connect(provider.getSigner());
              try {
                const tx = await contractWithSigner.setApprovalForAll(item.spender, this.modalApproval.approved);
                console.log("tx: " + JSON.stringify(tx));
              } catch (e) {
                console.log("updateApproval ERC-721 setApprovalForAll(...) error: " + JSON.stringify(e));
              }
            } else if (item.type == 'erc1155' && item.approvalType == 'ApprovalForAll') {
              const contract = new ethers.Contract(item.contract, ERC1155ABI, provider);
              const contractWithSigner = contract.connect(provider.getSigner());
              try {
                const tx = await contractWithSigner.setApprovalForAll(this.modalApproval.item.spender, this.modalApproval.approved);
                console.log("tx: " + JSON.stringify(tx));
              } catch (e) {
                console.log("updateApproval ERC-1155 setApprovalForAll(...) error: " + JSON.stringify(e));
              }
            }
          },

          async syncIt(devMode) {
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.coinbase = await signer.getAddress();
            localStorage.stealthChadCoinbase = this.coinbase;
            const network = await provider.getNetwork();
            localStorage.stealthChadChainId = network.chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " syncIt - latestBlockNumber: " + latestBlockNumber + ", chainId: " + this.chainId);
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncAnnouncements(db, provider, latestBlockNumber);
            }
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncRegistryEvents(db, provider, latestBlockNumber);
            }
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncAnnouncementsData(db, provider, latestBlockNumber);
            }
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncRegistryEventsData(db, provider, latestBlockNumber);
            }
            if (network.chainId == CHAINID_SEPOLIA) {
              await this.collateAccounts(db, provider, latestBlockNumber);
            }
            // TODO
            // if (network.chainId == CHAINID_MAINNET) {
            //   await this.syncENSNames(provider);
            // }
            // if (!devMode) {
            //   await this.processDataOld(provider);
            // }
            if (network.chainId == CHAINID_SEPOLIA) {
              await this.processData(db, provider, latestBlockNumber);
            }
            await this.loadCurrentData();
            this.forceRefresh++; // UI refresh workaround
            this.sync.section = null;
            this.sync.halt = false;
            db.close();
          },

          async syncAnnouncements(db, provider, latestBlockNumber) {
            // Announcement (index_topic_1 uint256 schemeId, index_topic_2 address stealthAddress, index_topic_3 address caller, bytes ephemeralPublicKey, bytes metadata)
            // 0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7
            const erc5564AnnouncerContract = new ethers.Contract(ERC5564ANNOUNCERADDRESS_SEPOLIA, ERC5564ANNOUNCERABI_SEPOLIA, provider);
            let total = 0;
            let t = this;
            async function processLogs(fromBlock, toBlock, selectedContracts, selectedCallers, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " syncAnnouncements.processLogs: " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  const logData = erc5564AnnouncerContract.interface.parseLog(log);
                  const contract = log.address;
                  const caller = logData.args[2];
                  if (selectedContracts.includes(contract) && selectedCallers.includes(caller)) {
                    records.push( {
                      chainId: t.chainId,
                      blockNumber: parseInt(log.blockNumber),
                      logIndex: parseInt(log.logIndex),
                      txIndex: parseInt(log.transactionIndex),
                      txHash: log.transactionHash,
                      contract,
                      name: logData.name,
                      schemeId: parseInt(logData.args[0]),
                      stealthAddress: logData.args[1],
                      caller,
                      ephemeralPublicKey: logData.args[3],
                      metadata: logData.args[4],
                      confirmations: latestBlockNumber - log.blockNumber,
                      timestamp: null,
                      tx: null,
                      stealthMetaAddress: null,
                    });
                  }
                }
              }
              // console.log("records: " + JSON.stringify(records, null, 2));
              if (records.length) {
                await db.announcements.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncAnnouncements.bulkPut error: " + error);
                });
              }
            }
            async function getLogs(fromBlock, toBlock, selectedContracts, selectedCallers, processLogs) {
              console.log(moment().format("HH:mm:ss") + " syncAnnouncements.getLogs: " + fromBlock + " - " + toBlock);
              try {
                const filter = {
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [
                    '0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7',
                    null,
                    null
                  ]
                };
                const eventLogs = await provider.getLogs(filter);
                await processLogs(fromBlock, toBlock, selectedContracts, selectedCallers, eventLogs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, selectedContracts, selectedCallers, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, selectedContracts, selectedCallers, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncAnnouncements BEGIN");
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'Stealth Address Announcements';
            const selectedContracts = [];
            const selectedCallers = [];
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                if (contractData.type == "announcer" && contractData.read) {
                  selectedContracts.push(contract);
                }
                if (contractData.type == "caller" && contractData.read) {
                  selectedCallers.push(contract);
                }
              }
            }
            if (selectedContracts.length > 0) {
              const deleteCall = await db.announcements.where("confirmations").below(this.CONFIRMATIONS).delete();
              const latest = await db.announcements.where('[chainId+blockNumber+logIndex]').between([this.chainId, Dexie.minKey, Dexie.minKey],[this.chainId, Dexie.maxKey, Dexie.maxKey]).last();
              const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
              await getLogs(startBlock, latestBlockNumber, selectedContracts, selectedCallers, processLogs);
            }
            console.log(moment().format("HH:mm:ss") + " syncAnnouncements END");
          },

          async syncRegistryEvents(db, provider, latestBlockNumber) {
            // Note: Following is ERC-6538: Stealth Meta-Address Registry with registrant being bytes32 instead of bytes
            // StealthMetaAddressSet (index_topic_1 bytes32 registrant, index_topic_2 uint256 scheme, bytes stealthMetaAddress)
            // 0x0bb4b5456abb9a4e7e0624d821e95e2fcc8a761c9227b5d761ae0da4a3fda233
            const erc5564RegistryContract = new ethers.Contract(ERC5564REGISTRYADDRESS_SEPOLIA, ERC5564REGISTRYABI_SEPOLIA, provider);
            let total = 0;
            let t = this;
            async function processLogs(fromBlock, toBlock, selectedContracts, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " syncRegistryEvents.processLogs: " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  const logData = erc5564RegistryContract.interface.parseLog(log);
                  const contract = log.address;
                  if (selectedContracts.includes(contract)) {
                    records.push( {
                      chainId: t.chainId,
                      blockNumber: parseInt(log.blockNumber),
                      logIndex: parseInt(log.logIndex),
                      txIndex: parseInt(log.transactionIndex),
                      txHash: log.transactionHash,
                      contract,
                      name: logData.name,
                      registrant: ethers.utils.getAddress("0x" + logData.args[0].substring(26, 66)),
                      schemeId: parseInt(logData.args[1]),
                      stealthMetaAddress: ethers.utils.toUtf8String(logData.args[2]),
                      confirmations: latestBlockNumber - log.blockNumber,
                      timestamp: null,
                      tx: null,
                    });
                  }
                }
              }
              // console.log("records: " + JSON.stringify(records, null, 2));
              if (records.length) {
                await db.registryEntries.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncRegistryEvents.bulkPut error: " + error);
                });
              }
            }
            async function getLogs(fromBlock, toBlock, selectedContracts, processLogs) {
              console.log(moment().format("HH:mm:ss") + " syncRegistryEvents.getLogs: " + fromBlock + " - " + toBlock);
              try {
                const filter = {
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [
                    '0x0bb4b5456abb9a4e7e0624d821e95e2fcc8a761c9227b5d761ae0da4a3fda233',
                    null,
                    null
                  ]
                };
                const eventLogs = await provider.getLogs(filter);
                await processLogs(fromBlock, toBlock, selectedContracts, eventLogs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, selectedContracts, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, selectedContracts, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncRegistryEvents BEGIN");
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'Stealth Address Registry';
            const selectedContracts = [];
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                if (contractData.type == "registry" && contractData.read) {
                  selectedContracts.push(contract);
                }
              }
            }
            if (selectedContracts.length > 0) {
              const deleteCall = await db.registryEntries.where("confirmations").below(this.CONFIRMATIONS).delete();
              const latest = await db.registryEntries.where('[chainId+blockNumber+logIndex]').between([this.chainId, Dexie.minKey, Dexie.minKey],[this.chainId, Dexie.maxKey, Dexie.maxKey]).last();
              const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
              await getLogs(startBlock, latestBlockNumber, selectedContracts, processLogs);
            }
            console.log(moment().format("HH:mm:ss") + " syncRegistryEvents END");
          },

          async syncAnnouncementsData(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData BEGIN");
            let rows = 0;
            let done = false;
            do {
              let data = await db.announcements.offset(rows).limit(this.DBPROCESSINGBATCHSIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              rows = parseInt(rows) + data.length;
              done = data.length < this.DBPROCESSINGBATCHSIZE;
            } while (!done);
            // let total = rows;
            // console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData - total: " + total);
            this.sync.completed = 0;
            this.sync.total = rows;
            this.sync.section = 'Announcements Tx Data';
            rows = 0;
            do {
              let data = await db.announcements.offset(rows).limit(this.DBPROCESSINGBATCHSIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              const records = [];
              for (const item of data) {
                // console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData: " + JSON.stringify(item));
                if (item.timestamp == null && item.chainId == this.chainId) {
                  const block = await provider.getBlock(item.blockNumber);
                  item.timestamp = block.timestamp;
                  const tx = await provider.getTransaction(item.txHash);
                  const txReceipt = await provider.getTransactionReceipt(item.txHash);
                  item.tx = {
                    type: tx.type,
                    blockHash: tx.blockHash,
                    from: tx.from,
                    gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
                    gasLimit: ethers.BigNumber.from(tx.gasLimit).toString(),
                    to: tx.to,
                    value: ethers.BigNumber.from(tx.value).toString(),
                    nonce: tx.nonce,
                    data: tx.to && tx.data || null, // Remove contract creation data to reduce memory footprint
                    chainId: tx.chainId,
                    contractAddress: txReceipt.contractAddress,
                    transactionIndex: txReceipt.transactionIndex,
                    gasUsed: ethers.BigNumber.from(txReceipt.gasUsed).toString(),
                    blockHash: txReceipt.blockHash,
                    logs: txReceipt.logs,
                    cumulativeGasUsed: ethers.BigNumber.from(txReceipt.cumulativeGasUsed).toString(),
                    effectiveGasPrice: ethers.BigNumber.from(txReceipt.effectiveGasPrice).toString(),
                    status: txReceipt.status,
                    type: txReceipt.type,
                  };
                  records.push(item);
                }
              }
              if (records.length > 0) {
                await db.announcements.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncAnnouncementsData.bulkPut error: " + error);
                });
              }
              rows = parseInt(rows) + data.length;
              this.sync.completed = rows;
              done = data.length < this.DBPROCESSINGBATCHSIZE;
            } while (!done);
          },

          async syncRegistryEventsData(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData BEGIN");
            let rows = 0;
            let done = false;
            do {
              let data = await db.registryEntries.offset(rows).limit(this.DBPROCESSINGBATCHSIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              rows = parseInt(rows) + data.length;
              done = data.length < this.DBPROCESSINGBATCHSIZE;
            } while (!done);
            // let total = rows;
            // console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData - total: " + total);
            this.sync.completed = 0;
            this.sync.total = rows;
            this.sync.section = 'Registry Entries Tx Data';
            rows = 0;
            do {
              let data = await db.registryEntries.offset(rows).limit(this.DBPROCESSINGBATCHSIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              const records = [];
              for (const item of data) {
                // console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData: " + JSON.stringify(item));
                if (item.timestamp == null && item.chainId == this.chainId) {
                  const block = await provider.getBlock(item.blockNumber);
                  item.timestamp = block.timestamp;
                  const tx = await provider.getTransaction(item.txHash);
                  const txReceipt = await provider.getTransactionReceipt(item.txHash);
                  item.tx = {
                    type: tx.type,
                    blockHash: tx.blockHash,
                    from: tx.from,
                    gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
                    gasLimit: ethers.BigNumber.from(tx.gasLimit).toString(),
                    to: tx.to,
                    value: ethers.BigNumber.from(tx.value).toString(),
                    nonce: tx.nonce,
                    data: tx.to && tx.data || null, // Remove contract creation data to reduce memory footprint
                    chainId: tx.chainId,
                    contractAddress: txReceipt.contractAddress,
                    transactionIndex: txReceipt.transactionIndex,
                    gasUsed: ethers.BigNumber.from(txReceipt.gasUsed).toString(),
                    blockHash: txReceipt.blockHash,
                    logs: txReceipt.logs,
                    cumulativeGasUsed: ethers.BigNumber.from(txReceipt.cumulativeGasUsed).toString(),
                    effectiveGasPrice: ethers.BigNumber.from(txReceipt.effectiveGasPrice).toString(),
                    status: txReceipt.status,
                    type: txReceipt.type,
                  };
                  records.push(item);
                }
              }
              if (records.length > 0) {
                await db.registryEntries.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncRegistryEventsData.bulkPut error: " + error);
                });
              }
              rows = parseInt(rows) + data.length;
              this.sync.completed = rows;
              done = data.length < this.DBPROCESSINGBATCHSIZE;
            } while (!done);
          },

          async collateAccounts(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " collateAccounts BEGIN");
            const accounts = this.accounts;
            let rows = 0;
            let done = false;
            do {
              let data = await db.announcements.offset(rows).limit(this.DBPROCESSINGBATCHSIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " collateAccounts - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (!(item.contract in accounts)) {
                  const name = CUSTOMNAMES[item.contract] && CUSTOMNAMES[item.contract].name || null;
                  accounts[item.contract] = { type: "account", source: "announcer.contract", mine: false, name };
                }
                if (!(item.stealthAddress in accounts)) {
                  accounts[item.stealthAddress] = { type: "account", source: "announcer.stealthAddress", mine: null, name: null };
                }
                if (!(item.caller in accounts)) {
                  const name = CUSTOMNAMES[item.caller] && CUSTOMNAMES[item.caller].name || null;
                  accounts[item.caller] = { type: "account", source: "announcer.caller", mine: null, name };
                }
                if (!(item.tx.from in accounts)) {
                  accounts[item.tx.from] = { type: "account", source: "announcer.sender", mine: item.tx.from == this.coinbase, name: null };
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DBPROCESSINGBATCHSIZE;
            } while (!done);
            rows = 0;

            done = false;
            do {
              let data = await db.registryEntries.offset(rows).limit(this.DBPROCESSINGBATCHSIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " collateAccounts - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (!(item.contract in accounts)) {
                  const name = CUSTOMNAMES[item.contract] && CUSTOMNAMES[item.contract].name || null;
                  accounts[item.contract] = { type: "account", source: "registry.contract", mine: false, name };
                }
                if (!(item.registrant in accounts)) {
                  accounts[item.registrant] = { type: "account", source: "registry.registrant", mine: null, name: null };
                }
                if (!(item.stealthMetaAddress in accounts)) {
                  accounts[item.stealthMetaAddress] = { type: "stealthMetaAddress", source: "registry.stealthMetaAddress", linkedTo: item.registrant };
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DBPROCESSINGBATCHSIZE;
            } while (!done);

            for (const [address, accountData] of Object.entries(accounts)) {
              if (accountData.type == "stealthMetaAddress") {
                const linkedToData = accountData.linkedTo && accounts[accountData.linkedTo] || null;
                if (linkedToData && linkedToData.mine) {
                  accounts[address].mine = true;
                }
              }
            }

            Vue.set(this, 'accounts', accounts);
            localStorage.stealthChadAccounts = JSON.stringify(this.accounts);
            console.log(moment().format("HH:mm:ss") + " collateAccounts - accounts: " + JSON.stringify(accounts, null, 2));
            console.log(moment().format("HH:mm:ss") + " collateAccounts END");
          },

          async processData(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " processData BEGIN");
            const checkAccounts = [];
            for (const [address, accountData] of Object.entries(this.accounts)) {
              if (accountData.type == "stealthMetaAddress" /*&& mine */) {
                checkAccounts.push({ address, ...accountData });
              }
            }
            console.log(moment().format("HH:mm:ss") + " processData - checkAccounts: " + JSON.stringify(checkAccounts));

            let rows = 0;
            let done = false;
            do {
              let data = await db.announcements.offset(rows).limit(this.DBPROCESSINGBATCHSIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " processData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                console.log(moment().format("HH:mm:ss") + " processData - stealthAddress: " + item.stealthAddress + ", ephemeralPublicKey: " + item.ephemeralPublicKey.substring(0, 20) + '... @ ' + item.blockNumber);
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DBPROCESSINGBATCHSIZE;
            } while (!done);
            rows = 0;

            // done = false;
            // do {
            //   let data = await db.registryEntries.offset(rows).limit(this.DBPROCESSINGBATCHSIZE).toArray();
            //   console.log(moment().format("HH:mm:ss") + " processData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
            //   for (const item of data) {
            //     if (!(item.contract in accounts)) {
            //       const name = CUSTOMNAMES[item.contract] && CUSTOMNAMES[item.contract].name || null;
            //       accounts[item.contract] = { type: "account", source: "registry.contract", mine: false, name };
            //     }
            //     if (!(item.registrant in accounts)) {
            //       accounts[item.registrant] = { type: "account", source: "registry.registrant", mine: null, name: null };
            //     }
            //     if (!(item.stealthMetaAddress in accounts)) {
            //       accounts[item.stealthMetaAddress] = { type: "stealthMetaAddress", source: "registry.stealthMetaAddress", linkedTo: item.registrant };
            //     }
            //   }
            //   rows = parseInt(rows) + data.length;
            //   done = data.length < this.DBPROCESSINGBATCHSIZE;
            // } while (!done);

            // for (const [address, accountData] of Object.entries(accounts)) {
            //   if (accountData.type == "stealthMetaAddress") {
            //     const linkedToData = accountData.linkedTo && accounts[accountData.linkedTo] || null;
            //     // console.log(moment().format("HH:mm:ss") + " processData: " + address + " => " + JSON.stringify(accountData, null, 2));
            //     // console.log(moment().format("HH:mm:ss") + "   => " + JSON.stringify(linkedToData, null, 2));
            //     if (linkedToData && linkedToData.mine) {
            //       accounts[address].mine = true;
            //     }
            //   }
            // }

            // Vue.set(this, 'accounts', accounts);
            // localStorage.stealthChadAccounts = JSON.stringify(this.accounts);

            // console.log(moment().format("HH:mm:ss") + " processData - accounts: " + JSON.stringify(accounts, null, 2));
            console.log(moment().format("HH:mm:ss") + " processData END");
          },


          async syncENSNames(provider) {
            console.log(moment().format("HH:mm:ss") + " syncENSNames BEGIN");
            const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
            for (const [chainId, chainData] of Object.entries(this.addresses)) {
              for (const [account, accountData] of Object.entries(chainData)) {
                const allnames = await ensReverseRecordsContract.getNames([account]);
                Vue.set(this.addresses[chainId][account], 'ensName', allnames.length >= 0 && allnames[0] || null);
                console.log(moment().format("HH:mm:ss") + " syncENSNames: " + account + " => " + (allnames.length >= 0 && allnames[0] || null));
              }
            }
            localStorage.stealthChadAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " syncENSNames END");
          },

          async processDataOld(provider) {
            function checkStealthAddress(stealthAddress, ephemeralPublicKey, viewingPrivateKey, spendingPublicKey) {
              const result = {};
              // console.log(moment().format("HH:mm:ss") + " processDataOld - checkStealthAddress - stealthAddress: " + stealthAddress + ", ephemeralPublicKey: " + ephemeralPublicKey + ", viewingPrivateKey: " + viewingPrivateKey + ", spendingPublicKey: " + spendingPublicKey);
              // console.log("    Check stealthAddress: " + stealthAddress + ", ephemeralPublicKey: " + ephemeralPublicKey + ", viewingPrivateKey: " + viewingPrivateKey + ", spendingPublicKey: " + spendingPublicKey);
              result.sharedSecret = nobleCurves.secp256k1.getSharedSecret(viewingPrivateKey.substring(2), ephemeralPublicKey.substring(2), false);
              result.hashedSharedSecret = ethers.utils.keccak256(result.sharedSecret.slice(1));
              result.hashedSharedSecretPoint = nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(result.hashedSharedSecret.substring(2));
              result.stealthPublicKey = nobleCurves.secp256k1.ProjectivePoint.fromHex(spendingPublicKey.substring(2)).add(result.hashedSharedSecretPoint);
              result.stealthAddress = ethers.utils.computeAddress("0x" + result.stealthPublicKey.toHex(false));
              result.match = result.stealthAddress == stealthAddress;
              return result;
            }

            function computeStealthKey(stealthAddress, ephemeralPublicKey, viewingPrivateKey, spendingPrivateKey) {
              const result = {};
              // console.log(moment().format("HH:mm:ss") + " processDataOld - checkStealthAddress - stealthAddress: " + stealthAddress + ", ephemeralPublicKey: " + ephemeralPublicKey + ", viewingPrivateKey: " + viewingPrivateKey + ", spendingPublicKey: " + spendingPublicKey);
              // console.log("    Check stealthAddress: " + stealthAddress + ", ephemeralPublicKey: " + ephemeralPublicKey); //  + ", viewingPrivateKey: " + viewingPrivateKey + ", spendingPrivateKey: " + spendingPrivateKey);
              result.sharedSecret = nobleCurves.secp256k1.getSharedSecret(viewingPrivateKey.substring(2), ephemeralPublicKey.substring(2), false);
              result.hashedSharedSecret = ethers.utils.keccak256(result.sharedSecret.slice(1));
              // console.log("hashedSharedSecret: " + result.hashedSharedSecret);
              // console.log("spendingPrivateKey: " + spendingPrivateKey);
              const stealthPrivateKeyNumber = (BigInt(spendingPrivateKey) + BigInt(result.hashedSharedSecret)) % BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");
              const stealthPrivateKeyString = stealthPrivateKeyNumber.toString(16);
              result.stealthPrivateKey = "0x" + stealthPrivateKeyString.padStart(64, '0');
              // console.log("      stealthPrivateKey: ", result.stealthPrivateKey);
              result.stealthPublicKey = "0x" +  nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(stealthPrivateKeyNumber).toHex(false);
              // console.log("      stealthPublicKey: ", result.stealthPublicKey.toHex(true));
              result.stealthAddress = ethers.utils.computeAddress(result.stealthPublicKey);
              // console.log("      stealthAddress: ", result.stealthAddress);
              return result;
            }

            console.log(moment().format("HH:mm:ss") + " processDataOld BEGIN");
            // console.log(moment().format("HH:mm:ss") + " processDataOld - events: " + JSON.stringify(this.events));
            // console.log(moment().format("HH:mm:ss") + " processDataOld - addresses: " + JSON.stringify(this.addresses));
            const events = this.events[this.chainId] || {};
            const addresses = this.addresses[this.chainId] || {};
            for (const blockNumber of Object.keys(events).sort((a, b) => { return a - b })) {
              for (const logIndex of Object.keys(events[blockNumber]).sort((a, b) => { return a - b })) {
                const eventData = events[blockNumber][logIndex];
                console.log(blockNumber + "." + logIndex + " " + eventData.stealthAddress + " " + eventData.ephemeralPublicKey);
                for (const [address, accountData] of Object.entries(addresses)) {
                  for (const [stealthMetaAddress, stealthMetaAddressData] of Object.entries(accountData.stealthMetaAddresses)) {
                    // console.log("  Checking " + address.substring(0, 20) + " " + stealthMetaAddress.substring(0, 30));
                    const stealthAddress = eventData.stealthAddress;
                    const ephemeralPublicKey = eventData.ephemeralPublicKey;
                    const viewingPrivateKey = stealthMetaAddressData.viewingPrivateKey;
                    const spendingPrivateKey = stealthMetaAddressData.spendingPrivateKey;
                    const spendingPublicKey = stealthMetaAddressData.spendingPublicKey;
                    const status = checkStealthAddress(stealthAddress, ephemeralPublicKey, viewingPrivateKey, spendingPublicKey);
                    console.log("    checkStealthAddress: " + (status && status.match));
                    // for (const [k, v] of Object.entries(status)) {
                    //   console.log("    ", k, "=>", v);
                    // }
                    if (status && status.match) {
                      const computedStealthKey = computeStealthKey(stealthAddress, ephemeralPublicKey, viewingPrivateKey, spendingPrivateKey);
                      console.log("      computedStealthKey: " + computedStealthKey.stealthAddress + " vs stealthAddress: " + stealthAddress);
                      // for (const [k, v] of Object.entries(computedStealthKey)) {
                      //   console.log("    ", k, "=>", v);
                      // }
                    }
                  }
                }
              }
            }
            console.log(moment().format("HH:mm:ss") + " processDataOld END");
          },

          async loadCurrentData() {
            console.log(moment().format("HH:mm:ss") + " loadCurrentData BEGIN");
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const announcements = await db.announcements.toArray();
            Vue.set(this, 'announcements', announcements);
            // console.log(moment().format("HH:mm:ss") + " announcements[0..2]: " + JSON.stringify(this.announcements.slice(0, 2), null, 2));
            const registryEntries = await db.registryEntries.toArray();
            Vue.set(this, 'registryEntries', registryEntries);
            // console.log(moment().format("HH:mm:ss") + " registryEntries[0..2]: " + JSON.stringify(this.registryEntries.slice(0, 2), null, 2));
            db.close();
            console.log(moment().format("HH:mm:ss") + " loadCurrentData END");
          },

          saveSettings() {
            // console.log(moment().format("HH:mm:ss") + " saveSettings: " + JSON.stringify(this.settings));
            localStorage.stealthChadSettings = JSON.stringify(this.settings);
          },
          async processNewBlock(blockNumber) {
            console.log(moment().format("HH:mm:ss") + " processNewBlock[" + this.chainId + "] #" + this.commify0(blockNumber) + ", latest #" + this.commify0(this.blockNumber) + " @ " + moment.unix(this.timestamp).format("YYYY-MM-DD HH:mm:ss") + " " + moment.unix(this.timestamp).fromNow());
          },
          async halt() {
            this.sync.halt = true;
            console.log(moment().format("HH:mm:ss") + " halt()");
          },
          commify0(n) {
            if (n != null) {
              return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            return null;
          },
          formatETH(e, precision = 9) {
            try {
              if (precision == 0) {
                return e ? ethers.utils.formatEther(e) : null;
              } else {
                return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
              }
            } catch (err) {
            }
            return e.toFixed(precision);
          },
          formatDecimals(e, decimals = 18) {
            return e ? ethers.utils.formatUnits(e, decimals) : null;
          },
          formatTimestamp(ts) {
            if (ts != null) {
              if (this.settings.reportingDateTime == 1) {
                return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
              } else {
                return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
              }
            }
            return null;
          },
          formatTimeDiff(unixtime) {
            if (!unixtime) {
              return "";
            } else {
              return moment.unix(unixtime).fromNow();
            }
          },
          nameOrAddress(address, length = 0) {
            let result = null;
            const account = this.accounts[address];
            if (account) {
              result = account.ensName || account.name || address;
            } else {
              result = address;
            }
            if (result && length > 0) {
              result = result.substring(0, length);
            }
            return result;
          },
          addressDescription(address) {
            const account = this.accounts[address];
            if (account) {
              result = "address=" + address;
              for (let key of [ 'type', 'linkedTo', 'customType', 'symbol', 'ensName', 'name', 'decimals', 'customDecimals', 'source', 'stealthMetaAddress' ]) {
                if (key in account) {
                  result = result + "; " + key + "=" + account[key];
                }
              }
            } else {
              result = address;
            }
            return result;
          },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          async connectToWeb3() {
            if (!window.ethereum) {
              this.connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                this.connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                this.connected = false;
              }
            }
            if (!this.connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const t = this;
              function handleChainChanged(_chainId) {
                t.chainId = _chainId;
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
                alert('Ethereum chain has changed - reloading this page.')
                window.location.reload();
              }
              window.ethereum.on('chainChanged', handleChainChanged);
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              async function handleAccountsChanged(accounts) {
                const signer = provider.getSigner();
                t.coinbase = await signer.getAddress();
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
              }
              window.ethereum.on('accountsChanged', handleAccountsChanged);
              async function handleNewBlock(blockNumber) {
                if (!t.blockNumber || blockNumber > t.blockNumber) {
                  const block = await provider.getBlock("latest");
                  t.blockNumber = block.number;
                  t.timestamp = block.timestamp;
                  await t.processNewBlock(blockNumber);
                }
              }
              provider.on("block", handleNewBlock);
              const signer = provider.getSigner();
              this.coinbase = await signer.getAddress();
              const network = await provider.getNetwork();
              this.chainId = network.chainId;
              console.log(moment().format("HH:mm:ss") + " connectToWeb3[" + this.chainId + "]");
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          (async() => {
            await this.connectToWeb3();
          })();
          if ('stealthChadChainId' in localStorage) {
            this.chainId = localStorage.stealthChadChainId;
          }
          if ('stealthChadCoinbase' in localStorage) {
            this.coinbase = localStorage.stealthChadCoinbase;
          }
          if ('stealthChadSettings' in localStorage) {
            const tempSettings = JSON.parse(localStorage.stealthChadSettings);
            if ('version' in tempSettings && tempSettings.version == this.settings.version) {
              this.settings = tempSettings;
              if (this.settings.activityTable.currentPage > 1) {
                this.settings.activityTable.currentPage = 1;
              }
              if (this.settings.registryActivityTable.currentPage > 1) {
                this.settings.registryActivityTable.currentPage = 1;
              }
              // Restore other settings for the same version
              if ('stealthChadContracts' in localStorage) {
                this.contracts = JSON.parse(localStorage.stealthChadContracts);
                // console.log(moment().format("HH:mm:ss") + " mounted - contracts: " + JSON.stringify(this.contracts));
              }
              // if ('stealthChadEvents' in localStorage) {
              //   this.events = JSON.parse(localStorage.stealthChadEvents);
              // }
              // if ('stealthChadRegistryEvents' in localStorage) {
              //   this.registryEvents = JSON.parse(localStorage.stealthChadRegistryEvents);
              // }
              // if ('stealthChadTxs' in localStorage) {
              //   this.txs = JSON.parse(localStorage.stealthChadTxs);
              // }
              if ('stealthChadAddresses' in localStorage) {
                this.addresses = JSON.parse(localStorage.stealthChadAddresses);
              }
              if ('stealthChadAccounts' in localStorage) {
                this.accounts = JSON.parse(localStorage.stealthChadAccounts);
                console.log(moment().format("HH:mm:ss") + " mounted - accounts: " + JSON.stringify(this.accounts, null, 2));
              }
              // if ('stealthChadBlockTimestamps' in localStorage) {
              //   this.blockTimestamps = JSON.parse(localStorage.stealthChadBlockTimestamps);
              // }
              // (async() => {
              //   // TODO: TESTING
              //   await delay(1500);
              //   await this.newStealthMetaAddress();
              // })();
            }
            (async() => {
              // const db = new Dexie(this.db.name);
              // db.version(this.db.version).stores(this.db.schemaDefinition);
              await this.loadCurrentData();
              // db.close();
            })();
          }
        },
      })
    </script>
  </body>
</html>
